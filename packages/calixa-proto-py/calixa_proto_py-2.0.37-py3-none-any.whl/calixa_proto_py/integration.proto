syntax = "proto3";

import "google/protobuf/empty.proto";
import "google/protobuf/struct.proto";
import "google/protobuf/timestamp.proto";
import "audience_sync.proto";
import "common.proto";
import "condition.proto";
import "entity.proto";
import "external_sync.proto";
import "integration_source.proto";
import "log.proto";
import "action.proto";
import "related_data.proto";

import "oltpannotation.proto";

option java_package = "io.calixa.domain.integration";
option java_multiple_files = true;
option optimize_for = SPEED;

package calixa.domain.integration;

message BigQueryCredentials {
  string project_id = 1;
}

message SnowflakeCredentials {
  //  https://docs.snowflake.com/en/user-guide/jdbc-configure.html#label-other-jdbc-connection-string-examples

  string account_identifier = 1;
  string query_execution_warehouse = 2;
  string user = 3;
  string password = 4; // TODO(freds): encrypt
  string role = 5;
  string database = 6;
  string schema = 7;
}

message RedshiftCredentials {
  //  TODO add doc link

  string endpoint = 1;
  string username = 2;
  string password = 3; // TODO(liviu): encrypt
}

message DummyCredentials {
  // exists so we can hide credentials in flows/stores that does not need them.
  // like snapshots of integration in logs.
}

message Credentials {
  oneof credentials {
    OAuthCredentials oauth = 100;
    BigQueryCredentials bigquery = 101;
    SnowflakeCredentials snowflake = 102;
    RedshiftCredentials redshift = 103;
    BasicCredentials basic = 104;
    DummyCredentials dummy = 500;
  }
}

enum IntegrationStatus {
  INTEGRATION_STATUS_UNSPECIFIED = 0;
  INTEGRATION_STATUS_ENABLED = 1;
  INTEGRATION_STATUS_PAUSED = 3;
  INTEGRATION_STATUS_FAILED = 4;
}

message Integration {
  reserved 16; // Deprecated string external_unique_integration_key

  string organization_id = 1;
  string instance_id = 2;
  string parent_instance_id = 19;

  string installed_by_user_id = 4;
  IntegrationSource source = 5;

  Credentials credentials = 6;
  IntegrationStatus status = 7;

  // key:value pairs needed to lookup an integration from webhooks we receive
  map<string, string> properties = 8;
  CredentialsStatus credentials_status = 9;

  google.protobuf.Timestamp installed_at = 10;
  google.protobuf.Timestamp created_at = 11;
  google.protobuf.Timestamp updated_at = 12;
  google.protobuf.Timestamp backfill_completed_at = 13;
  google.protobuf.Timestamp deleted_at = 14;
  google.protobuf.Timestamp last_synced_at = 20;
  google.protobuf.Timestamp last_job_run_at = 21;

  IntegrationChannel channel = 15;
  IntegrationStore store = 18;

  AirbyteMetadata airbyte_metadata = 17;
}

message BasicCredentials {
  string api_key = 1; //user
  string password = 2; //optional
}

message OAuthCredentials {
  // List of scopes we have access to.
  repeated string scopes = 1;

  // These fields are modeled after the official OAuth 2.0 spec:
  // https://www.oauth.com/oauth2-servers/access-tokens/access-token-response/
  string access_token = 4;
  string refresh_token = 5;
  string token_type = 6;
  google.protobuf.Timestamp token_granted_at = 7;
  int32 expires_in = 8;
}

service IntegrationService {

  // HealthCheck can be called periodically by the Platform to ensure that an integration
  // is doing well.
  rpc HealthCheck(HealthCheckRequest) returns (HealthCheckResponse);

  // Verifies that the credentials (parameters, config, etc) for an integration is correct
  // and ready for an install and on-going webhooks/incremental updates and backfill.
  rpc Verify(VerifyRequest) returns (VerifyResponse);

  // Performs a full install (this is different than verifying that credentials work) of
  // the integration for the Organization (and InstanceID).
  rpc Install(InstallRequest) returns (InstallResponse);

  // Performs a complete uninstall of the integration from 3rd party apps. Steps could include
  // - Revoke access token
  // - Remove configured webhooks settings
  rpc Uninstall(UninstallRequest) returns (UninstallResponse);

  // For more detailed workflow description, refer https://www.notion.so/Backfill-2-0-357737f0ba0a49ac97aa0074fe9878e1#fddaa33ff74d4351b5fb602aacc31d0c
  //
  // InitializeBackfill is called by the platform to fetch the initial set of BackfillTask's
  // required to start the backfill per entity_type. Current limit for the number of initial set of tasks is ten.
  //
  // The BackfillTask contains information, like time_range, page_cursor, to perform smallest unit of backfill work.
  // For example:
  //    backfill_page : {page: 1, per_page: 20, starting_after='page_cursor1'},
  //    backfill_time_range: {from_at: 1621238411, to_at: 1621299611}
  //
  // The platform saves the tasks to a postgres table for observability and status tracking,
  // and publishes the tasks to a pub/sub topic to be reliably delivered to the integrations for backfill.
  rpc InitializeBackfill(InitializeBackfillRequest) returns (InitializeBackfillResponse);

  // For more detailed workflow description, refer https://www.notion.so/Backfill-2-0-357737f0ba0a49ac97aa0074fe9878e1#fddaa33ff74d4351b5fb602aacc31d0c
  //
  // BackfillPartial is long running, slow, susceptible to errors from 3rd party api's and save entities to platform operations.
  // BackfillPartial is called by the platform, in a fire-and-forget manner, for each cursor, and it is responsible for the following:
  // 1. (slow, error prone) Fetches the data from 3rd party.
  // 2. (slow, error prone) Converts the fetched raw data into calixa entities and save each entity in graph by calling platform.
  rpc BackfillPartial(BackfillPartialRequest) returns (BackfillPartialResponse);

  // Called by the platform after a log entry for the integration has been
  // durably written.
  rpc ProcessLogEntry(ProcessLogEntryRequest) returns (ProcessLogEntryResponse);

  // Called by the IntegrationManager when a user tries to install an integration. This RPC
  // must return the URL that the browser is redirected to initiate the OAuth flow.
  rpc GetOAuthAuthenticationUrl(OAuthAuthenticationUrlRequest) returns (OAuthAuthenticationUrlResponse);

  // This RPC is called when the final step in the OAuth flow completes. The RPC must fetch
  // the access token (and other OAuth properties) from the third-party and return the OAuthCredentials
  rpc FinalizeOAuthIntegration(FinalizeOAuthIntegrationRequest) returns (FinalizeOAuthIntegrationResponse);

  // Called by ActionService to invoke action(s) on the 3rd party connected integration vendors like
  // Stripe, Intercom, Hubspot, Zendesk etc. Examples of action's could be
  // 1) (Stripe)   mark the invoice as paid, refund, etc.
  // 2) (Hubspot)  close the deal
  // 3) (Intercom) send a follow up message
  rpc InvokeAction(InvokeIntegrationActionRequest) returns (InvokeIntegrationActionResponse);

  // Fetches information that is not captured by entities inside Calixa or information
  // that needs a real time lookup, e.g.: Stripe Coupon
  rpc GetRelatedData(GetIntegrationRelatedDataRequest) returns (GetIntegrationRelatedDataResponse);
  // Paginated version of the API to fetch info not caputured by entities in Calixa
  // or needing real-time lookups, e.g.: Stripe Coupon
  rpc GetRelatedDataPaginated(GetIntegrationRelatedDataRequest) returns (GetIntegrationRelatedDataResponse);

  // Called by the IntegrationManager when a user tries to install an integrations. This RPC
  // must return a unique external identifier information from property bag that allows
  // to detect integration duplicates
  rpc GetUniqueExternalIdentifier(GetUniqueExternalIdentifierRequest) returns (GetUniqueExternalIdentifierResponse);

  // Called before integration credentials expire to prevent it from happening.
  // It helps keeping access and refresh tokens up-to-date.
  rpc RefreshTokens(RefreshTokensRequest) returns (RefreshTokensResponse);

  // Executes the bulk updates! The Python client will be very thin and the java code is responsible
  // for formatting the payload body.
  rpc BulkUpdate(BulkUpdateRequest) returns (BulkUpdateResponse);
}

enum OAuthFinalizedStatus {
  OAUTH_FINALIZED_STATUS_UNSPECIFIED = 0;
  OAUTH_FINALIZED_STATUS_SUCCESS = 1;

  // The user did not grant access to the 3rd party (i.e. did not click the
  // "Accept" link)
  OAUTH_FINALIZED_STATUS_ACCESS_DENIED = 2;
}

message OAuthAuthenticationUrlRequest {

  // This is a Platform-side generated UUID that is a temporary pointer to
  // the session state that must be specified in the URL with the field name
  // "state=..."
  string state = 1;

  // Raw POST body that is sent from the Console to start the OAuth Flow.
  // Zendesk, for instance, passes the parameter "subdomain" to the flow to
  // resolve the appropriate "Zendesk Support" instance to grant tokens from.
  //
  // This is sent as JSON encoded as a string. For instance:
  // { "subdomain": "my_company" }
  //
  // This field is optional; Intercom, for instance, does not pass any data.
  string json_encoded_post_params = 2;

  // The URI that the third party should redirect to. This is a well-formed
  // URI supplied by the Platform service that receives that callback then
  // delegates to the IntegrationService.
  string redirect_uri = 3;
}

message OAuthAuthenticationUrlResponse {
  // A fully formed HTTP URI that contains the state token and whatever
  // other required fields to initiate the OAuth flow with the 3rd party.
  string authentication_url = 1;
}

message FinalizeOAuthIntegrationRequest {

  // A map of name-value pairs received from the Third Party platform. This
  // map will contain 3rd-party specific name-value pairs.
  map<string, string> query_parameters = 1;

  // The **original** Raw POST body that was sent from the Console to start
  // the OAuth Flow.
  //
  // This is not part of the OAuth flow, but necessary for context for
  // some 3rd party integrations (namely Zendesk) that use non-standard
  // variants of OAuth.
  string json_encoded_post_params = 2;

  // The integration instance that captures the configuration (including the
  // OAuth properties).
  Integration integration = 3;

  // The URI that the third party should redirect to. While this URL is no longer
  // necessary as part of the data flow, the OAuth spec requires this field to
  // be passed in when an Access Token is requested to further verify the caller.
  // This is the exact same value that was passed in to call GetOAuthAuthenticationUrl
  string redirect_uri = 4;
}

message FinalizeOAuthIntegrationResponse {
  OAuthFinalizedStatus status = 1;

  // Optional; when status != SUCCESS, this field captures the error message
  // that was returned by the 3rd party.
  string message = 2;

  // The integration instance that captures the fully configured fields. This
  // is stored in the database after the flow completes.
  Integration integration = 3;
}

message ProcessLogEntryRequest {
  calixa.domain.log.WriteAheadLogEntry log_entry = 1;
}

message ProcessLogEntryResponse {
  calixa.domain.log.LogStatus status = 1;
}

message HealthCheckRequest {
  // Intentionally left blank
}

enum HealthCheckStatus {
  HEALTH_CHECK_STATE_UNSPECIFIED = 0;
  HEALTH_CHECK_STATE_OK = 1;
  HEALTH_CHECK_STATE_UNHEALTHY = 2;
}

message HealthCheckResponse {
  HealthCheckStatus status = 1;
}

enum CredentialsStatus {
  CREDENTIALS_STATUS_UNSPECIFIED = 0;
  CREDENTIALS_STATUS_OK = 1;
  CREDENTIALS_STATUS_REJECTED = 2;
}

enum InstallStatus {
  INSTALL_STATUS_UNSPECIFIED = 0;
  INSTALL_STATUS_OK = 1;
  INSTALL_STATUS_FAILED = 2;
  INSTALL_STATUS_DUPLICATE = 3;
}

enum UninstallStatus {
  UNINSTALL_STATUS_UNSPECIFIED = 0;
  UNINSTALL_STATUS_SUCCESS = 1;
  UNINSTALL_STATUS_FAILURE = 2;
  // For details on NOOP status usage by integration app, refer
  // https://www.notion.so/Uninstall-integration-flow-10e4e11c74874883a1c193db1ddd66d9#1a86d8c0483949a5ba614b7ddaa98458
  UNINSTALL_STATUS_NOOP = 3;
}

message AirbyteMetadata {
  string workspace_id = 1;
  string source_id = 2;
  // map of connection ids to their unique name in airbyte
  // we form the unique name with various factors that will
  // make sense to us and not airbyte
  map<string, string> connection_ids = 4;
  int64 sync_frequency_millis = 5;
  calixa.domain.common.SyncStatus sync_status = 6;
}

message VerifyRequest {
  Integration integration = 1;
}

message VerifyResponse {

  CredentialsStatus status = 1;

  // Optionally populated when status != 1 to capture what the Vendor told us about
  // the keys.
  string message = 2;
}

message InstallRequest {
  Integration integration = 1;
}

message UninstallRequest {
  Integration integration = 1;
}

message InstallResponse {
  InstallStatus status = 1;
}

message UninstallResponse {
  UninstallStatus status = 1;
  string response = 2;
}

message InitializeBackfillRequest {
  Integration integration = 1;
  google.protobuf.Timestamp backfill_from = 2 [deprecated = true];
  google.protobuf.Timestamp backfill_to = 3 [deprecated = true];
}

enum CursorStatus {
  CURSOR_STATUS_UNSPECIFIED = 0;
  CURSOR_STATUS_PROCESSED = 1;
  CURSOR_STATUS_ERROR = 2;
  CURSOR_STATUS_PENDING = 3;
}

message Cursor {
  string organization_id = 1;
  string cursor_id = 2;
  string instance_id = 3;
  calixa.domain.integration.IntegrationSource source = 4;
  google.protobuf.Timestamp cursor_from = 5;
  google.protobuf.Timestamp cursor_to = 6;
  CursorStatus status = 7;
  bool last_cursor = 8;

  // These are managed internally by the service.
  google.protobuf.Timestamp internal_created_at = 1005;
  google.protobuf.Timestamp internal_updated_at = 1006;
}

message InitializeBackfillResponse {
  reserved 1; // was initial_backfill_tasks
  repeated Cursor backfill_cursors = 2 [deprecated = true];
}

message BackfillPartialRequest {
  Integration integration = 1 [deprecated = true];
  repeated Cursor cursors = 2 [deprecated = true];
  reserved 3;  // was backfillTask;
}

message BackfillPartialResponse {
  reserved 1;  // was status
  string response = 2;
}

message InvokeIntegrationActionRequest {
  calixa.domain.action.ActionParams action_params = 1;
  calixa.domain.entity.Entity entity = 2;
  Integration integration = 3;
}

message InvokeIntegrationActionResponse {
  calixa.domain.action.ActionInvocationStatus action_status = 1;
  calixa.domain.action.ThirdPartyActionInvocationResponse raw_response_payload = 2;
  calixa.domain.relateddata.ExceptionResponse exception_response = 3;
}

message GetIntegrationRelatedDataRequest {
  calixa.domain.relateddata.RelatedDataType related_data_type = 1;
  Integration integration = 2;
  string filter = 3; // used as query param on 3rd party apis to filter related data
  map<string, string> params = 4;
  string page_token = 5;
  int32 page_size = 6;
}

message GetIntegrationRelatedDataResponse {
  repeated calixa.domain.relateddata.RelatedData related_data = 1;
  calixa.domain.relateddata.ExceptionResponse exception_response = 2;
  string next_page_token = 3;
}

message GetUniqueExternalIdentifierRequest {
  Integration integration = 1;
}

message GetUniqueExternalIdentifierResponse {
  string unique_external_identifier_key = 1;
  string unique_external_identifier_value = 2;
}

message BackfillTimeRange {
  google.protobuf.Timestamp from_updated_at = 1;
  google.protobuf.Timestamp to_updated_at = 2;
}

message PageRequest {
  // the page number. one-based index, page starts from 1
  int32 page = 1;
  // number of items to be returned in the page
  int32 items_per_page = 2;
}

message PageResponse {
  // total number of items on all pages
  int32 total_items = 1;
  // total number of available pages
  int32 total_pages = 2;
  // next available page. -1 indicates no page is available next.
  int32 next_available_page = 4;
}

message RefreshTokensRequest {
  Integration integration = 1;
}

enum RefreshTokensStatus {
  REFRESH_TOKENS_STATUS_UNSPECIFIED = 0;
  REFRESH_TOKENS_STATUS_SUCCESS = 1;

  // Access might have been revoked.
  REFRESH_TOKENS_ACCESS_DENIED = 2;
  REFRESH_TOKENS_FAILED = 3;
}

message RefreshTokensResponse {
  RefreshTokensStatus status = 1;

  // Optional; when status != SUCCESS, this field captures the error message
  // that was returned by the 3rd party.
  string message = 2;

  // The integration instance containing updated credentials. The
  // credentials field is stored in the database after the flow completes.
  Integration integration = 3;
}

message BulkUpdateRequest {

  // Captures the necessary keys (oauth)
  Integration integration = 1;

  // Contains information about what fields to outbound sync as well as entity types and
  // source-specific configs
  calixa.domain.externalsync.ExternalSyncDefinition external_sync_definition = 2 [deprecated = true];

  // For the MVP, we're going to render a string. In future versions this
  // field can be replaced with structured fields. For SFDC, this is a CSV.
  string payload = 3;

  // Contains information about what fields to sync as well as entity types and
  // source-specific configs
  calixa.domain.audience.AudienceSync audience_sync = 4;
}

enum BulkUpdateResponseStatus {
  BULK_UPDATE_RESPONSE_STATUS_UNSPECIFIED=0;
  BULK_UPDATE_RESPONSE_STATUS_SUCCESS=1;
  BULK_UPDATE_RESPONSE_STATUS_FAILED=2;
}

message BulkUpdateResponse {
  BulkUpdateResponseStatus status = 1;

  // Error message returned by 3rd party (if not successful) to be stored in logs
  string message = 3;
}
