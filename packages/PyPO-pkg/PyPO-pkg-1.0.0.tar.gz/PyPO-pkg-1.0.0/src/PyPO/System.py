# Standard Python imports
from scipy.optimize import fmin
from scipy.interpolate import interp1d, griddata
import matplotlib.pyplot as pt
import matplotlib.cm as cm
import numpy as np
import time
import os
import copy
import logging
from pathlib import Path
import pickle 

# PyPO-specific modules
from PyPO.BindRefl import *
from PyPO.BindGPU import *
from PyPO.BindCPU import *
from PyPO.BindBeam import *
from PyPO.BindTransf import *
from PyPO.MatTransform import *
from PyPO.PyPOTypes import *
from PyPO.Checks import *
import PyPO.Config as Config
from PyPO.CustomLogger import CustomLogger
import PyPO.Plotter as plt
import PyPO.Efficiencies as effs
import PyPO.FitGauss as fgs

import PyPO.WorldParam as world

# Set PyPO absolute root path
sysPath = Path(__file__).parents[2]
logging.getLogger(__name__)

##
# @file
# System interface for PyPO.
#
# This script contains the System class definition.
class System(object):
    customBeamPath = os.getcwd()
    customReflPath = os.getcwd()
    savePathSystems = os.getcwd()


    ##
    # Constructor. Initializes system state.
    #
    # @param redirect Redirect all print statements within system to given stdout.
    # @param context Whether system is created in script or in GUI.
    # @param verbose Enable system logger.
    # @param override Allow overriding names.
    def __init__(self, redirect=None, context=None, verbose=True, override=True):
        self.num_ref = 0
        self.num_cam = 0
        self.nThreads_cpu = os.cpu_count()
        self.context = context
        self.verbosity = verbose

        Config.setContext(context)
        Config.setOverride(override)

        ##
        # The internal system dictionary.
        #
        # This dictionary holds the user-defined reflector/element dictionaries.
        # The key of the entry is the name of the reflector/element.
        # The reflector/element dictionary itself is stored as the item corresponding to the key.
        #
        # @ingroup public_api_internaldicts 
        self.system = {}
        
        ##
        # The internal frames dictionary.
        #
        # This dictionary holds all ray-trace frames generated by `PyPO`.
        # The frames are stored as key-value pairs, where the key is the name given to the frame.
        # The item stored at the key is the frame itself.
        #
        # @ingroup public_api_internaldicts 
        self.frames = {}
        
        ##
        # The internal PO fields dictionary.
        #
        # This dictionary holds all PO fields generated by `PyPO`.
        # The fields are stored as key-value pairs, where the key is the name given to the PO field.
        # The item stored at the key is the PO field itself.
        #
        # @ingroup public_api_internaldicts 
        self.fields = {}
        
        ##
        # The internal PO currents dictionary.
        #
        # This dictionary holds all PO currents generated by `PyPO`.
        # The currents are stored as key-value pairs, where the key is the name given to the PO current.
        # The item stored at the key is the PO current itself.
        #
        # @ingroup public_api_internaldicts 
        self.currents = {}
        
        ##
        # The internal PO scalarfields dictionary.
        #
        # This dictionary holds all PO scalarfields generated by `PyPO`.
        # The scalarfields are stored as key-value pairs, where the key is the name given to the PO scalarfield.
        # The item stored at the key is the PO scalarfield itself.
        #
        # @ingroup public_api_internaldicts 
        self.scalarfields = {}

        ##
        # The internal groups dictionary.
        #
        # This dictionary holds all defined groups.
        # The key under which a group is stored is the name of that group.
        #
        # @ingroup public_api_internaldicts 
        self.groups = {}
        
        ##
        # The internal associations dictionary.
        #
        # This dictionary contains an overview of Poynting vector ray-trace frames and the corresponding reflected PO field.
        # The key in the dictionary is the name of the surface on which the frame and PO field are defined.
        # In `PyPO` language, this is called an association, as in, the frame and PO field are associated on the same surface.
        # This is important for doing hybrid propagations, where the field is propagated using the reflected Poynting vectors and reflected PO field.
        # If a user attempts to do a hybrid propagation with a frame and PO field that are not associated, the `System` will log an error.
        #
        # @ingroup public_api_internaldicts
        self.assoc = {}

        self.EHcomplist = np.array(["Ex", "Ey", "Ez", "Hx", "Hy", "Hz"])
        self.JMcomplist = np.array(["Jx", "Jy", "Jz", "Mx", "My", "Mz"])

        self.cl = 2.99792458e11 # mm / s
        #self.savePathElem = "./save/elements/"

        saveSystemsExist = os.path.isdir(self.savePathSystems)

        if not saveSystemsExist:
            os.makedirs(self.savePathSystems)
        
        self.savePath = os.getcwd() 

        existSave = os.path.isdir(self.savePath)

        if not existSave:
            os.makedirs(self.savePath)
        
        #redirect = None
        if redirect is None:
            self.clog_mgr = CustomLogger(os.path.basename(__file__))
            self.clog = self.clog_mgr.getCustomLogger()

        else:
            self.clog = redirect

        if not verbose:
            self.clog.setLevel(logging.CRITICAL)

        if context == "S":
            self.clog.info("INITIALIZED EMPTY SYSTEM.")
 
        if override == True:
            self.clog.warning("System override set to True.")
       
    ##
    # Destructor. Deletes any reference to the logger assigned to current system.
    def __del__(self):
        if self.context != "G":
            self.clog.info("EXITING SYSTEM.")
            del self.clog_mgr
            del self.clog
    
    ##
    # @brief Obtain a reference to the custom logger used by system.
    #
    # This method can be called to obtain a reference to the logging object that PyPO uses internally.
    # Can be convenient in cases one wants to log their own information in the layout of the PyPO logger.
    #
    # @ingroup public_api_sysio
    #
    # @returns clog Reference to system logger.
    def getSystemLogger(self):
        return self.clog

    ##
    # Print system contents.
    def __str__(self):
        s = "Contents of system:\n"
        s += f"Reflectors {len(self.system)}:\n"
        for key in self.system.keys():
            s += f"    {key}\n"
        s += f"Groups {len(self.groups)}:\n"
        for key in self.groups.keys():
            s += f"    {key}\n"
        s += f"Frames {len(self.frames)}:\n"
        for key in self.frames.keys():
            s += f"    {key}\n"
        s += f"Currents {len(self.currents)}:\n"
        for key in self.currents.keys():
            s += f"    {key}\n"
        s += f"Fields {len(self.fields)}:\n"
        for key in self.fields.keys():
            s += f"    {key}\n"
        s += f"Scalar Fields {len(self.scalarfields)}:\n"
        for key in self.scalarfields.keys():
            s += f"    {key}\n"
        return s

    ##
    # @brief Set path to folder containing custom beam patterns.
    #
    # Set the path to the directory where PyPO looks for custom beam patterns.
    # When a custom beam pattern is imported using the readCustomBeam() method, PyPO will look in the specified path for the beam patterns. 
    #
    # @ingroup public_api_sysio
    #
    # @param path Path to custom beams.
    # @param append Whether path is relative to current working directory or absolute from home.
    def setCustomBeamPath(self, path, append=False):
        if append:
            self.customBeamPath = os.path.join(self.customBeamPath, path)
        else:
            self.customBeamPath = path

    ##
    # Set path to folder were to save output plots.
    #
    # Set the path to the directory where PyPO saves output plots.
    #
    # @ingroup public_api_sysio
    #
    # @param path Path to save directory.
    # @param append Whether path is relative to current working directory or absolute from home.
    def setSavePath(self, path, append=False):
        if append:
            self.savePath = os.path.join(self.savePath, path)

        else:
            self.savePath = path

        if not os.path.isdir(self.savePath):
            os.makedirs(self.savePath)
 
    ##
    # Set path to folder were to save systems.
    #
    # Set the path to the directory where PyPO saves systems.
    #
    # @ingroup public_api_sysio
    #
    # @param path Path to save directory.
    # @param append Whether path is relative to current working directory or absolute from home.
    def setSavePathSystems(self, path, append=False):
        if append:
            self.savePathSystems = os.path.join(self.savePathSystems, path)

        else:
            self.savePathSystems = path

        if not os.path.isdir(self.savePathSystems):
            os.makedirs(self.savePathSystems)

    ##
    # Set the verbosity of the logging from within the system.
    #
    # Sometimes it is preferrable to not generate logging output to the console, for example when PyPO methods are called in for loops.
    # This method allows for on/off switching of the logging unit so that the console is not flooded with logging messages.
    #
    # @ingroup public_api_sysio
    #
    # @param verbose Whether to enable logging or not.
    # @param handler If multiple handlers are present, select which handler to adjust.
    def setLoggingVerbosity(self, verbose=True, handler=None):
        self.verbosity = verbose
        if verbose == True:
            self.clog.setLevel(logging.DEBUG)
        else:
            self.clog.setLevel(logging.CRITICAL)

    ##
    # Add a paraboloid reflector to the System.
    #
    # This method takes a dictionary filled with the parameters for a paraboloid reflector and generates an internal dictionary for generating the reflectorgrids. 
    #
    # @ingroup public_api_reflmeths
    #
    # @param reflDict A filled reflectordictionary. Will raise an exception if not properly filled.
    def addParabola(self, reflDict):

        reflDict["type"] = 0

        _reflDict = self.copyObj(reflDict)
        check_ElemDict(_reflDict, self.system.keys(), self.clog) 
        self.system[_reflDict["name"]] = _reflDict

        if _reflDict["pmode"] == "focus":
            self.system[_reflDict["name"]]["coeffs"] = np.zeros(3)

            ve = _reflDict["vertex"] # Vertex point position
            f1 = _reflDict["focus_1"] # Focal point position

            diff = f1 - ve

            df = np.sqrt(np.dot(diff, diff))
            a = 2 * np.sqrt(df)
            b = a

            orientation = diff / np.sqrt(np.dot(diff, diff))
            offTrans = ve

            R = self.findRotation(world.IAX(), orientation)
            
            self.system[_reflDict["name"]]["transf"] = MatTranslate(offTrans, R)
            self.system[_reflDict["name"]]["pos"] = (self.system[_reflDict["name"]]["transf"] @ np.append(self.system[_reflDict["name"]]["pos"], 1))[:-1]
            self.system[_reflDict["name"]]["ori"] = R[:-1, :-1] @ self.system[_reflDict["name"]]["ori"]

            self.system[_reflDict["name"]]["coeffs"][0] = a
            self.system[_reflDict["name"]]["coeffs"][1] = b
            self.system[_reflDict["name"]]["coeffs"][2] = -1

        elif _reflDict["pmode"] == "manual":
            self.system[_reflDict["name"]]["coeffs"] = np.array([_reflDict["coeffs"][0], _reflDict["coeffs"][1], -1])

        if _reflDict["gmode"] == "xy" or _reflDict["gmode"] == 0:
            self.system[_reflDict["name"]]["gmode"] = 0

        elif _reflDict["gmode"] == "uv" or _reflDict["gmode"] == 1:
            self.system[_reflDict["name"]]["gmode"] = 1
        
        self.system[_reflDict["name"]]["snapshots"] = {}
        self.clog.info(f"Added paraboloid {_reflDict['name']} to system.")
        self.num_ref += 1

    ##
    # Add a hyperboloid reflector to the System.
    #
    # This method takes a dictionary filled with the parameters for a hyperboloid reflector and generates an internal dictionary for generating the reflectorgrids. 
    #
    # @ingroup public_api_reflmeths
    #
    # @param reflDict A filled reflectordictionary. Will raise an exception if not properly filled.
    def addHyperbola(self, reflDict):

        reflDict["type"] = 1
        _reflDict = self.copyObj(reflDict)
        check_ElemDict(_reflDict, self.system.keys(), self.clog) 
        self.system[_reflDict["name"]] = _reflDict
        
        if _reflDict["pmode"] == "focus":
            self.system[_reflDict["name"]]["coeffs"] = np.zeros(3)
            # Calculate a, b, c of hyperbola
            f1 = _reflDict["focus_1"] # Focal point 1 position
            f2 = _reflDict["focus_2"] # Focal point 2 position
            ecc = _reflDict["ecc"] # Eccentricity of hyperbola

            diff = f1 - f2
            c = np.sqrt(np.dot(diff, diff)) / 2
            a = c / ecc
            b = np.sqrt(c**2 - a**2)

            # Convert 2D hyperbola a,b,c to 3D hyperboloid a,b,c
            a3 = b
            b3 = b
            c3 = a

            # Find direction between focii
            orientation = diff / np.linalg.norm(diff)

            # Find offset from center. Use offset as rotation origin for simplicity
            center = (f1 + f2) / 2
            offTrans = center

            # Find rotation in frame of center
            R = self.findRotation(world.IAX(), orientation)
            
            self.system[_reflDict["name"]]["transf"] = MatTranslate(offTrans, R)

            self.system[_reflDict["name"]]["pos"] = (self.system[_reflDict["name"]]["transf"] @ np.append(self.system[_reflDict["name"]]["pos"], 1))[:-1]
            self.system[_reflDict["name"]]["ori"] = R[:-1, :-1] @ self.system[_reflDict["name"]]["ori"]

            self.system[_reflDict["name"]]["coeffs"][0] = a3
            self.system[_reflDict["name"]]["coeffs"][1] = b3
            self.system[_reflDict["name"]]["coeffs"][2] = c3

        if _reflDict["gmode"] == "xy" or _reflDict["gmode"] == 0:
            self.system[_reflDict["name"]]["gmode"] = 0

        elif _reflDict["gmode"] == "uv" or _reflDict["gmode"] == 1:
            self.system[_reflDict["name"]]["gmode"] = 1

        self.system[_reflDict["name"]]["snapshots"] = {}
        self.clog.info(f"Added hyperboloid {_reflDict['name']} to system.")
        self.num_ref += 1

    ##
    # Add an ellipsoid reflector to the System.
    #
    # This method takes a dictionary filled with the parameters for an ellipsoid reflector and generates an internal dictionary for generating the reflectorgrids. 
    #
    # @ingroup public_api_reflmeths
    #
    # @param reflDict A filled reflectordictionary. Will raise an exception if not properly filled.
    def addEllipse(self, reflDict):

        reflDict["type"] = 2
        _reflDict = self.copyObj(reflDict)
        check_ElemDict(_reflDict, self.system.keys(), self.clog) 
        self.system[_reflDict["name"]] = _reflDict
        
        if _reflDict["pmode"] == "focus":
            self.system[_reflDict["name"]]["coeffs"] = np.zeros(3)
            f1 = _reflDict["focus_1"]
            f2 = _reflDict["focus_2"]
            ecc = _reflDict["ecc"]

            diff = f1 - f2

            trans = (f1 + f2) / 2

            f_norm = diff / np.linalg.norm(diff)
            
            if _reflDict["orient"] == "x":
                R = self.findRotation(np.array([1,0,0]), f_norm)
            
            if _reflDict["orient"] == "z":
                R = self.findRotation(np.array([0,0,1]), f_norm)

            a = np.sqrt(np.dot(diff, diff)) / (2 * ecc)
            b = a * np.sqrt(1 - ecc**2)
            
            #_transf = MatRotate(rotation, _reflDict["transf"])
            self.system[_reflDict["name"]]["transf"] = MatTranslate(trans, R)
            
            self.system[_reflDict["name"]]["pos"] = (self.system[_reflDict["name"]]["transf"] @ np.append(self.system[_reflDict["name"]]["pos"], 1))[:-1]
            self.system[_reflDict["name"]]["ori"] = R[:-1, :-1] @ self.system[_reflDict["name"]]["ori"]

            if _reflDict["orient"] == "x":
                self.system[_reflDict["name"]]["coeffs"][0] = a
                self.system[_reflDict["name"]]["coeffs"][1] = b
                self.system[_reflDict["name"]]["coeffs"][2] = b
            
            if _reflDict["orient"] == "z":
                self.system[_reflDict["name"]]["coeffs"][0] = b
                self.system[_reflDict["name"]]["coeffs"][1] = b
                self.system[_reflDict["name"]]["coeffs"][2] = a

        if _reflDict["gmode"] == "xy" or _reflDict["gmode"] == 0:
            self.system[_reflDict["name"]]["gmode"] = 0

        elif _reflDict["gmode"] == "uv" or _reflDict["gmode"] == 1:
            self.system[_reflDict["name"]]["gmode"] = 1

        check_ellipseLimits(self.system[_reflDict["name"]], self.clog)

        self.system[_reflDict["name"]]["snapshots"] = {}
        self.clog.info(f"Added ellipsoid {_reflDict['name']} to system.")
        self.num_ref += 1

    ##
    # Add a planar surface to the System.
    #
    # This method takes a dictionary filled with the parameters for a planar reflector and generates an internal dictionary for generating the reflectorgrids. 
    #
    # @ingroup public_api_reflmeths
    #
    # @param reflDict A filled reflectordictionary. Will raise an exception if not properly filled.
    def addPlane(self, reflDict):

        reflDict["type"] = 3
        _reflDict = self.copyObj(reflDict)
        check_ElemDict(_reflDict, self.system.keys(), self.clog) 
        
        self.system[_reflDict["name"]] = _reflDict
        self.system[_reflDict["name"]]["coeffs"] = np.zeros(3)

        self.system[_reflDict["name"]]["coeffs"][0] = -1
        self.system[_reflDict["name"]]["coeffs"][1] = -1
        self.system[_reflDict["name"]]["coeffs"][2] = -1

        if _reflDict["gmode"] == "xy" or _reflDict["gmode"] == 0:
            self.system[_reflDict["name"]]["gmode"] = 0

        elif _reflDict["gmode"] == "uv" or _reflDict["gmode"] == 1:
            self.system[_reflDict["name"]]["gmode"] = 1

        elif _reflDict["gmode"] == "AoE" or _reflDict["gmode"] == 2:
            self.system[_reflDict["name"]]["gmode"] = 2

        self.system[_reflDict["name"]]["snapshots"] = {}
        self.clog.info(f"Added plane {_reflDict['name']} to system.")
        self.num_ref += 1
   
    ##
    # Rotate reflector grids.
    #
    # Apply a rotation, around a center of rotation, to a reflector, group or frame.
    # Note that an absolute orientation rotates the orientation such that it is oriented w.r.t. the z-axis.
    # In this case, the pivot defaults to the origin and not to the specified pivot.
    # In the case that a PO field and/or a PO current is associated with the reflector, the polarisation of the field and/or current is rotated along as well.
    # This can be disabled by setting the "keep_pol" parameter to "True".
    #
    # @ingroup public_api_common 
    #
    # @param name Reflector name or list of reflector names.
    # @param rotation Numpy ndarray of length 3, containing rotation angles around x, y and z axes, in degrees.
    # @param obj Whether the name corresponds to a single element or group.
    # @param mode Apply rotation relative ('relative') to current orientation, or rotate to specified orientation ('absolute').
    # @param pivot Numpy ndarray of length 3, containing pivot x, y and z co-ordinates, in mm. Defaults to pos. 
    # @param keep_pol Keep polarisation of a field/current defined on the surface, if present.
    def rotateGrids(self, name, rotation, obj="element", mode="relative", pivot=None, keep_pol=False):

        if obj == "element":
            check_elemSystem(name, self.system, self.clog, extern=True)
            pivot = self.system[name]["pos"] if pivot is None else pivot
            
            if mode == "absolute":
                match = world.IAX()
                match_rot = (MatRotate(rotation))[:-1, :-1] @ match
                R = self.findRotation(self.system[name]["ori"], match_rot)

                Tp = self.copyObj(world.INITM())
                Tpm = self.copyObj(world.INITM())
                Tp[:-1,-1] = pivot
                Tpm[:-1,-1] = -pivot
                
                Rtot = Tp @ R @ Tpm
                self.system[name]["transf"] = Rtot @ self.system[name]["transf"]
                self.system[name]["transf"][:-1, :-1] = (MatRotate(rotation, pivot=pivot))[:-1, :-1]

                self.system[name]["pos"] = (Rtot @ np.append(self.system[name]["pos"], 1))[:-1]
                self.system[name]["ori"] = Rtot[:-1, :-1] @ self.system[name]["ori"]

                if not keep_pol:
                    self._checkBoundPO(name, Rtot)

                self.clog.info(f"Rotated element {name} to {*['{:0.3e}'.format(x) for x in list(rotation)],} degrees around {*['{:0.3e}'.format(x) for x in list(pivot)],}.")

            elif mode == "relative":
                self.system[name]["transf"] = MatRotate(rotation, self.system[name]["transf"], pivot)
                
                self.system[name]["pos"] = (MatRotate(rotation, pivot=pivot) @ np.append(self.system[name]["pos"], 1))[:-1]
                self.system[name]["ori"] = MatRotate(rotation)[:-1, :-1] @ self.system[name]["ori"]
                
                if not keep_pol:
                    self._checkBoundPO(name, MatRotate(rotation))
            
                self.clog.info(f"Rotated element {name} by {*['{:0.3e}'.format(x) for x in list(rotation)],} degrees around {*['{:0.3e}'.format(x) for x in list(pivot)],}.")

        elif obj == "group":
            check_groupSystem(name, self.groups, self.clog, extern=True)
            pivot = self.groups[name]["pos"] if pivot is None else pivot
            
            if mode == "absolute":
                match = world.IAX()
                match_rot = (MatRotate(rotation))[:-1, :-1] @ match
                R = self.findRotation(self.system[name]["ori"], match_rot)

                Tp = self.copyObj(world.INITM())
                Tpm = self.copyObj(world.INITM())
                Tp[:-1,-1] = pivot
                Tpm[:-1,-1] = -pivot
                
                Rtot = Tp @ R @ Tpm
                
                for self.system[elem] in self.groups[name]["members"]:
                    self.system[elem]["transf"] = Rtot @ self.system[elem]["transf"]
                    self.system[elem]["transf"][:-1, :-1] = (MatRotate(rotation, pivot=pivot))[:-1, :-1]

                    self.system[elem]["pos"] = (Rtot @ np.append(self.system[elem]["pos"], 1))[:-1]
                    self.system[elem]["ori"] = Rtot[:-1, :-1] @ self.system[elem]["ori"]
                    
                    if not keep_pol:
                        self._checkBoundPO(elem, Rtot)

                self.groups[name]["pos"] = (Rtot @ np.append(self.groups[name]["pos"], 1))[:-1]
                self.groups[name]["ori"] = Rtot[:-1, :-1] @ self.groups[name]["ori"]
                
                self.clog.info(f"Rotated group {name} to {*['{:0.3e}'.format(x) for x in list(rotation)],} degrees around {*['{:0.3e}'.format(x) for x in list(pivot)],}.")

            elif mode == "relative":
                for elem in self.groups[name]["members"]:
                    self.system[elem]["transf"] = MatRotate(rotation, self.system[elem]["transf"], pivot)
                    
                    self.system[elem]["pos"] = (MatRotate(rotation, pivot=pivot) @ np.append(self.system[elem]["pos"], 1))[:-1]
                    self.system[elem]["ori"] = MatRotate(rotation)[:-1, :-1] @ self.system[elem]["ori"]
                    
                    if not keep_pol:
                        self._checkBoundPO(elem, MatRotate(rotation))

                self.groups[name]["pos"] = (MatRotate(rotation, pivot=pivot) @ np.append(self.groups[name]["pos"], 1))[:-1]
                self.groups[name]["ori"] = MatRotate(rotation)[:-1, :-1] @ self.groups[name]["ori"]
                
                self.clog.info(f"Rotated group {name} by {*['{:0.3e}'.format(x) for x in list(rotation)],} degrees around {*['{:0.3e}'.format(x) for x in list(pivot)],}.")

        if obj == "frame":
            check_frameSystem(name, self.frames, self.clog, extern=True)
            pivot = self.frames[name].pos if pivot is None else pivot
            
            if mode == "absolute":
                match = world.IAX()
                match_rot = (MatRotate(rotation))[:-1, :-1] @ match
                R = self.findRotation(self.frames[name].ori, match_rot)

                Tp = self.copyObj(world.INITM())
                Tpm = self.copyObj(world.INITM())
                Tp[:-1,-1] = pivot
                Tpm[:-1,-1] = -pivot
                
                Rtot = Tp @ R @ Tpm

                self.frames[name].transf = Rtot
                #self.frames[name].transf[:-1, :-1] = (MatRotate(rotation, pivot=pivot))[:-1, :-1]
                _fr = transformRays(self.frames[name])
                self.frames[name] = self.copyObj(_fr)

                self.frames[name].pos = (Rtot @ np.append(self.frames[name].pos, 1))[:-1]
                self.frames[name].ori = Rtot[:-1, :-1] @ self.frames[name].ori
                self.clog.info(f"Rotated element {name} to {*['{:0.3e}'.format(x) for x in list(rotation)],} degrees around {*['{:0.3e}'.format(x) for x in list(pivot)],}.")

            elif mode == "relative":
                self.frames[name].transf = MatRotate(rotation, pivot=pivot)
                _fr = transformRays(self.frames[name])
                self.frames[name] = self.copyObj(_fr)
                
                self.frames[name].pos = (MatRotate(rotation, pivot=pivot) @ np.append(self.frames[name].pos, 1))[:-1]
                self.frames[name].ori = MatRotate(rotation)[:-1, :-1] @ self.frames[name].ori
            
                self.clog.info(f"Rotated frame {name} by {*['{:0.3e}'.format(x) for x in list(rotation)],} degrees around {*['{:0.3e}'.format(x) for x in list(pivot)],}.")

    ##
    # Translate reflector grids.
    #
    # Apply a translation to a reflector, group or frame.
    # If the translation is absolute, the object will be translated such that its internal position parameter coincides with the specified translation.
    #
    # @ingroup public_api_common 
    #
    # @param name Reflector name or list of reflector names.
    # @param translation Numpy ndarray of length 3, containing translation x, y and z co-ordinates, in mm.
    # @param obj Whether the name corresponds to a single element or group.
    # @param mode Apply translation relative ('relative') to current position, or move to specified position ('absolute').
    def translateGrids(self, name, translation, obj="element", mode="relative"):

        _translation = self.copyObj(translation)
        
        if obj == "element":
            if mode == "absolute":
                _translation -= self.system[name]["pos"]# - translation
            
            check_elemSystem(name, self.system, self.clog, extern=True)
            self.system[name]["transf"] = MatTranslate(_translation, self.system[name]["transf"])
            self.system[name]["pos"] += _translation
            
            if mode == "absolute":
                self.clog.info(f"Translated element {name} to {*['{:0.3e}'.format(x) for x in list(_translation)],} millimeters.")
            else:
                self.clog.info(f"Translated element {name} by {*['{:0.3e}'.format(x) for x in list(_translation)],} millimeters.")
        
        elif obj == "group":
            if mode == "absolute":
                _translation -= self.groups[name]["pos"]# - translation
            
            check_groupSystem(name, self.groups, self.clog, extern=True)
            for elem in self.groups[name]["members"]:
                self.system[elem]["transf"] = MatTranslate(_translation, self.system[elem]["transf"])
                self.system[elem]["pos"] += _translation
            
            self.groups[name]["pos"] += _translation
            
            if mode == "absolute":
                self.clog.info(f"Translated group {name} to {*['{:0.3e}'.format(x) for x in list(_translation)],} millimeters.")
            
            else:
                self.clog.info(f"Translated group {name} by {*['{:0.3e}'.format(x) for x in list(_translation)],} millimeters.")

        elif obj == "frame":
            if mode == "absolute":
                _translation -= self.frames[name].pos# - translation
            
            check_frameSystem(name, self.frames, self.clog, extern=True)
            

            self.frames[name].transf = MatTranslate(_translation)
            _fr = transformRays(self.frames[name])
            self.frames[name] = self.copyObj(_fr)
            self.frames[name].pos += _translation
            
            if mode == "absolute":
                self.clog.info(f"Translated frame {name} to {*['{:0.3e}'.format(x) for x in list(_translation)],} millimeters.")
            else:
                self.clog.info(f"Translated frame {name} by {*['{:0.3e}'.format(x) for x in list(_translation)],} millimeters.")
    
    ##
    # Home a reflector or a group back into default configuration.
    #
    # Set internal transformation matrix of a reflector or group to identity. 
    #
    # @ingroup public_api_reflmeths
    #
    # @param name Reflector name or list of reflector or group to be homed.
    # @param obj Type of object to be homed.
    # @param trans Home (translate) back to home position.
    # @param rot Home (rotate) back to home orientation.
    def homeReflector(self, name, obj="element", trans=True, rot=True):
        if obj == "group":
            check_groupSystem(name, self.groups, self.clog, extern=True)
            if trans:
                for elem in self.groups[name]["members"]:
                    _transf = self.copyObj(world.INITM())
                    _transf[:-1, :-1] = self.system[elem]["transf"][:-1, :-1]
                    self.system[elem]["transf"] = _transf
                    self.system[elem]["pos"] = self.copyObj(world.ORIGIN())

                self.groups[name]["pos"] = self.copyObj(world.ORIGIN())
            
            if rot:
                for elem in self.groups[name]["members"]:
                    _transf = self.system[elem]["transf"]
                    _transf[:-1, :-1] = np.eye(3)
                    self.system[elem]["transf"] = _transf
                
                self.groups[name]["ori"] = self.copyObj(world.IAX())
            
            self.clog.info(f"Transforming group {name} to home position.")

                    
        else:
            check_elemSystem(name, self.system, self.clog, extern=True)
            if trans:
                _transf = self.copyObj(world.INITM())
                _transf[:-1, :-1] = self.system[name]["transf"][:-1, :-1]
                self.system[name]["transf"] = _transf
                self.system[name]["pos"] = self.copyObj(world.ORIGIN())

            
            if rot:
                _transf = self.system[name]["transf"]
                _transf[:-1, :-1] = np.eye(3)
                self.system[name]["transf"] = _transf
                self.system[name]["ori"] = self.copyObj(world.IAX())
            
            self.clog.info(f"Transforming element {name} to home position.")
 
    ##
    # Take and store snapshot of object's current configuration.
    #
    # A snapshot consists of the transformation matrix of an element, group of frame.
    #
    # @ingroup public_api_reflmeths
    #
    # @param name Name of object to be snapped.
    # @param snap_name Name of snapshot to save.
    # @param obj Whether object is an element, group or frame.
    def snapObj(self, name, snap_name, obj="element"):
        if obj == "group":
            check_groupSystem(name, self.groups, self.clog, extern=True)
            self.groups[name]["snapshots"][snap_name] = []

            for elem in self.groups[name]["members"]:
                self.groups[name]["snapshots"][snap_name].append(self.copyObj(self.system[elem]["transf"]))
            
            self.clog.info(f"Saved snapshot {snap_name} for group {name}.")
        
        elif obj == "element":
            check_elemSystem(name, self.system, self.clog, extern=True)
            self.system[name]["snapshots"][snap_name] = self.copyObj(self.system[name]["transf"])

            self.clog.info(f"Saved snapshot {snap_name} for element {name}.")
        
        elif obj == "frame":
            check_frameSystem(name, self.frames, self.clog, extern=True)
            self.frames[name].snapshots[snap_name] = self.copyObj(self.frames[name].transf)

            self.clog.info(f"Saved snapshot {snap_name} for frame {name}.")
    
    ##
    # Revert object configuration to a saved snapshot.
    #
    # Reverting an object to a snapshot replaces the internal transformation matrix with the matrix stored in the snapshot.
    #
    # @ingroup public_api_reflmeths
    #
    # @param name Name of obj to revert.
    # @param snap_name Name of snapshot to revert to.
    # @param obj Whether object is an element, group or frame.
    def revertToSnap(self, name, snap_name, obj="element"):
        if obj == "group":
            check_groupSystem(name, self.groups, self.clog, extern=True)

            for elem, snap in zip(self.groups[name]["members"], self.groups[name]["snapshots"][snap_name]):
                self._checkBoundPO(elem, InvertMat(self.system[elem]["transf"]))
                self.system[elem]["transf"] = self.copyObj(snap)
                self._checkBoundPO(elem, self.system[elem]["transf"])
            
            self.clog.info(f"Reverted group {name} to snapshot {snap_name}.")

        elif obj == "element":
            check_elemSystem(name, self.system, self.clog, extern=True)
            self._checkBoundPO(name, InvertMat(self.system[name]["transf"]))
            self.system[name]["transf"] = self.copyObj(self.system[name]["snapshots"][snap_name])
            self._checkBoundPO(name, self.system[name]["transf"]) 
            self.clog.info(f"Reverted element {name} to snapshot {snap_name}.")
        elif obj == "frame":
            check_frameSystem(name, self.frames, self.clog, extern=True)
            self.frames[name].transf = self.copyObj(self.frames[name].snapshots[snap_name])
            
            _fr = transformRays(self.frames[name])
            self.frames[name] = self.copyObj(_fr)
            
            self.clog.info(f"Reverted frame {name} to snapshot {snap_name}.")
    
    ##
    # Delete a saved snapshot belonging to an object.
    #
    # This deletes the stored snapshot, including the associated transformation matrix.
    #
    # @ingroup public_api_reflmeths
    #
    # @param name Name of object.
    # @param snap_name Name of snapshot to delete.
    # @param obj Whether object is an element or a group.
    def deleteSnap(self, name, snap_name, obj="element"):
        if obj == "group":
            check_groupSystem(name, self.groups, self.clog, extern=True)
           
            del self.groups[name]["snapshots"][snap_name]

            self.clog.info(f"Deleted snapshot {snap_name} belonging to group {name}.")

        elif obj == "element":
            del self.system[name]["snapshots"][snap_name]

            self.clog.info(f"Deleted snapshot {snap_name} belonging to element {name}.")
        
        elif obj == "frame":
            del self.frames[name].snapshots[snap_name]

            self.clog.info(f"Deleted snapshot {snap_name} belonging to frame {name}.")
    
    ##
    # Group elements together into a single block. After grouping, can translate, rotate and characterise as one.
    #
    # This method adds a new field to the internal groups dictionary, with the key being the given name of the group.
    # The item corresponding to this key is, again, a dictionary. The first key, "members", corresponds to a list containing the names of the reflectors added to the group.
    # The position and orientation trackers of the group are set to the origin and the z-axis, respectively, if not passed as arguments.
    #
    # @ingroup public_api_reflmeths
    #
    # @param names Names of elements to put in group.
    # @param name_group Name of the group.
    # @param pos Position tracker for the group.
    # @param ori Orientation tracker for group.
    def groupElements(self, name_group, *names, pos=None, ori=None):
        num = getIndex(name_group, self.groups.keys())

        if num > 0:
            name_group = name_group + "_{}".format(num)
        pos = world.ORIGIN() if pos is None else pos
        ori = world.IAX() if ori is None else ori

        for _name in names:
            check_elemSystem(_name, self.system, self.clog, extern=True)

        self.groups[name_group] = {
                "members"   : list(names),
                "pos"       : pos,
                "ori"       : ori,
                "snapshots" : {}
                }
        self.clog.info(f"Grouped elements {names} into group {name_group}.")

    ##
    # Remove a group of elements from system. Note that this does not remove the elements inside the group.
    #
    # Removing a group only removes the key and item in the internal groups dictionary and does not remove the contained elements.
    #
    # @ingroup public_api_reflmeths
    #
    # @param name_group Name of the group to be removed.
    def removeGroup(self, name_group):
        check_groupSystem(ng, self.groups, self.clog, extern=True)
        del self.groups[name_group]
        
        self.clog.info(f"Removed group {name_group} from system.")

    ##
    # Generate reflector grids and normals.
    # 
    # Evaluate a stored reflector dictionary and return the x, y, z grids, area and normals.
    # The outputs are grouped together in a grids object.
    #
    # @ingroup public_api_reflmeths
    #
    # @param name Name of reflector to be gridded.
    # @param transform Apply internal transformation matrix to reflector.
    # @param spheric Return spheric or square far-field grid (far-field only).
    #
    # @return grids A reflGrids object containing the grids, area and normals.
    #
    # @see reflGrids
    def generateGrids(self, name, transform=True, spheric=True):
        check_elemSystem(name, self.system, self.clog, extern=True)
        grids = generateGrid(self.system[name], transform, spheric)
        return grids
    
    ##
    # Save a system object to disk. 
    #
    # The system from which this method is called will be saved in its entirety, e.g. all reflectors, fields, currents and frames, to disk.
    # The directory to which the system will be saved will either be the current working directory or the directory specified with setSavePathSystems().
    #
    # @ingroup public_api_sysio
    #
    # @param name Save the current system under this name.
    def saveSystem(self, name):
        path = os.path.join(self.savePathSystems, name)
        saveExist = os.path.isdir(path)

        if not saveExist:
            os.makedirs(path)
        
        with open(os.path.join(path, "system.pys"), 'wb') as file: 
            pickle.dump(self.system, file)
        
        with open(os.path.join(path, "groups.pys"), 'wb') as file: 
            pickle.dump(self.groups, file)
        
        with open(os.path.join(path, "frames.pys"), 'wb') as file: 
            pickle.dump(self.frames, file)
        
        with open(os.path.join(path, "fields.pys"), 'wb') as file: 
            pickle.dump(self.fields, file)
       
        with open(os.path.join(path, "currents.pys"), 'wb') as file: 
            pickle.dump(self.currents, file)
        
        with open(os.path.join(path, "scalarfields.pys"), 'wb') as file: 
            pickle.dump(self.scalarfields, file)
        
        self.clog.info(f"Saved current system to {name}.")

    ##
    # Load a system object from /save/systems/. This loads all reflectors, fields, currents and frames in the system from disk.
    #
    # The system from which this method is called will be overwritten in its entirety, e.g. all reflectors, fields, currents and frames will be replaced with the 
    # internal dictionaries of the system to load.
    # The directory from which the system will be saved will either be the current working directory or the directory specified with setSavePathSystems().
    #
    # @ingroup public_api_sysio
    #
    # @param name Load the system under this name.
    def loadSystem(self, name):
        self.clog.info(f"Loading system {name} from {self.savePathSystems} into current system.")
        path = os.path.join(self.savePathSystems, name)
        loadExist = os.path.isdir(path)

        if not loadExist:
            self.clog.error("Specified system does not exist.")
            exit(1)

        with open(os.path.join(path, "system.pys"), 'rb') as file: 
            self.system = pickle.load(file)
        
        with open(os.path.join(path, "groups.pys"), 'rb') as file: 
            self.groups = pickle.load(file)
        
        with open(os.path.join(path, "frames.pys"), 'rb') as file: 
            self.frames = pickle.load(file)
        
        with open(os.path.join(path, "fields.pys"), 'rb') as file: 
            self.fields = pickle.load(file)
        
        with open(os.path.join(path, "currents.pys"), 'rb') as file: 
            self.currents = pickle.load(file)
        
        with open(os.path.join(path, "scalarfields.pys"), 'rb') as file: 
            self.scalarfields = pickle.load(file)

    ##
    # Merge multiple systems together into current system.
    # 
    # This method takes a arbitrary amount of system objects and updates the internal dictionaries of the system from which this method is called.
    # This means that the calling system will keep its internal dictionaries. However, if the systems contain a key in the internal dictionaries
    # matching a key in the calling system, this key and item will be overwritten.
    #
    # @ingroup public_api_sysio
    #
    # @param systems Systems to be merged into current system
    def mergeSystem(self, *systems):
        if len(set(systems)) < len(systems):
            raise Exception("Cannot merge duplicate systems.")
        for sysObject in systems:
            sys_copy = self.copyObj(sysObject)
            
            self.system.update(sys_copy.system)
            self.fields.update(sys_copy.fields)
            self.currents.update(sys_copy.currents)
            self.frames.update(sys_copy.frames)
            self.groups.update(sys_copy.groups)
            self.scalarfields.update(sys_copy.scalarfields)
    
    ##
    # Remove reflector from system.
    #
    # This removes the key and corresponding reflector dictionary in the internal system dictionary.
    # It also check whether the element is included in a group.
    # If it is included in a group, the method will also remove the element from the "members" list of the group.
    #
    # @ingroup public_api_reflmeths
    #
    # @ param name Name of reflector to be removed.
    def removeElement(self, name):
        check_elemSystem(name, self.system, self.clog, extern=True)
        for group in self.groups.values():
            if name in group["members"]:
                group["members"].remove(name)
        del self.system[name]
        self.clog.info(f"Removed element {name} from system.")
    
    ##
    # Copy reflector.
    #
    # This method takes an internal reflector dictionary and generates a deepcopy, i.e. a true copy.
    # The copy can be adjusted safely without changing the contents of the original.
    #
    # @ingroup public_api_reflmeths
    #
    # @ param name Name of reflector to be copied.
    # @ param name_copy Name of new reflector.
    def copyElement(self, name, name_copy):
        check_elemSystem(name, self.system, self.clog, extern=True)
        self.system[name_copy] = self.copyObj(self.system[name])
        self.clog.info(f"Copied element {name} to {name_copy}.")
    
    ##
    # Copy group.
    #
    # This method takes a group name and generates a deepcopy, i.e. a true copy.
    # The copy can be adjusted safely without changing the contents of the original.
    # Note however that the elements themselves are not deepcopied.
    # This might change later on.
    #
    # @ingroup public_api_reflmeths
    #
    # @ param name Name of group to be copied.
    # @ param name_copy Name of new group.
    def copyGroup(self, name, name_copy):
        check_groupSystem(name, self.groups, self.clog, extern=True)
        self.groups[name_copy] = self.copyObj(self.groups[name])
        self.clog.info(f"Copied group {name} to {name_copy}.")
    
    ##
    # Remove a ray-trace frame from system.
    #
    # This method takes the name of an internally stored frame object and removes it from the internal dictionary.
    #
    # @ingroup public_api_frames
    #
    # @param frameName Name of frame to be removed.
    def removeFrame(self, frameName):
        check_frameSystem(frameName, self.frames, self.clog, extern=True)
        del self.frames[frameName]
        
        self.clog.info(f"Removed frame {frameName} from system.")
    
    ##
    # Remove a PO field from system.
    #
    # This method takes the name of an internally stored PO field object and removes it from the internal dictionary.
    #
    # @ingroup public_api_po
    #
    # @param fieldName Name of field to be removed.
    def removeField(self, fieldName):
        check_fieldSystem(fieldName, self.fields, self.clog, extern=True)
        del self.fields[fieldName]
        
        self.clog.info(f"Removed PO field {fieldName} from system.")
    
    ##
    # Remove a PO current from system.
    #
    # This method takes the name of an internally stored PO current object and removes it from the internal dictionary.
    #
    # @ingroup public_api_po
    #
    # @param curentName Name of current to be removed.
    def removeCurrent(self, currentName):
        check_currentSystem(currentName, self.currents, self.clog, extern=True)
        del self.currents[currentName]
        
        self.clog.info(f"Removed PO current {currentName} from system.")

    ##
    # Remove a scalar PO field from system.
    #
    # This method takes the name of an internally stored PO scalarfield object and removes it from the internal dictionary.
    #
    # @ingroup public_api_po
    #
    # @param fieldName Name of scalar field to be removed.
    def removeScalarField(self, fieldName):
        check_scalarfieldSystem(fieldName, self.scalarfields, self.clog, extern=True)
        del self.scalarfields[fieldName]
        
        self.clog.info(f"Removed scalar PO field {fieldName} from system.")
    
    ##
    # Read a custom beam from disk into the system. 
    #
    # The system will look in the customBeamPath, which defaults to the current working directory and can be set with the setCustomBeamPath() method.
    # Note that the custom beam pattern needs to contain a real and imaginary part, and that these need to be stored in separate .txt files, stored as
    # such: r<name_beam>.txt and i<name_beam>.txt, where 'r' and 'i' refer to the real and imaginary part, respectively.
    #
    # @ingroup public_api_po
    #
    # @param name_beam Name of the beam (without the 'r' or 'i' prefixes or '.txt' suffix).
    # @param name_source Name of source surface on which to define the beam. 
    # @param comp Polarisation component of beam.
    # @param lam Wavelength of beam, in mm.
    # @param normalise Whether or not to normalise beam to its maximum amplitude.
    # @para mode Which approximation to use. Can choose between Perfect Electrical Conductor ('PEC'), Perfect Magnetic Conductor ('PMC') or full calculation ('full'). Defaults to 'PMC'.
    # @param scale Scale factor for beam. Defaults to 1.
    #
    # @see setCustomBeamPath
    def readCustomBeam(self, name_beam, name_source, comp, lam, normalise=True, mode="PMC", scale=1):
        check_elemSystem(name_source, self.system, self.clog, extern=True)
        
        rfield = np.loadtxt(os.path.join(self.customBeamPath, "r" + name_beam + ".txt"))
        ifield = np.loadtxt(os.path.join(self.customBeamPath, "i" + name_beam + ".txt"))

        field = rfield + 1j*ifield

        if normalise:
            maxf = np.max(field)
            field /= maxf
            field *= scale

        k = 2 * np.pi / lam
 
        shape = self.system[name_source]["gridsize"]

        fields_c = self._compToFields(comp, field)
        fields_c.setMeta(name_source, k)
        self.fields[name_beam] = fields_c#.H()
        currents_c = calcCurrents(fields_c, self.system[name_source], mode)
        currents_c.setMeta(name_source, k)

        self.currents[name_beam] = currents_c

    ##
    # Calculate currents on a surface given a field object.
    #
    # Given a surface and a PO field defined on said surface it is possible to calculate the image PO currents, the virtual currents that would give rise to the PO field.
    # This is also known as the image theorem.
    # For this, it is necessary to give appropriate boundary conditions on the surface. This depends on the PO field that is present.
    # If only the electric field is known, the currents can be calculated by assuming a PMC (perfect magnetic conductor)
    # right behind the surface, which radiated the elctric fields.
    # In case only the magnetic field is know, the PMC is replaced by a PEC (perfect electric conductor).
    # In case both electric and magnetic fields are know, the boundary conditions for vectorial EM fields at the surface can be used to calculate the image currents.
    #
    # @ingroup public_api_po
    #
    # @param name_source Name of surface in which to calculate currents.
    # @param fields Fields object from which to calculate currents.
    # @para mode Which approximation to use. Can choose between Perfect Electrical Conductor ('PEC', requires H-field), Perfect Magnetic Conductor ('PMC', requires E-field) or full calculation ('full', requires both). Defaults to 'PMC'.
    #
    # @see fields
    # @see currents
    def calcCurrents(self, name_source, fields, mode="PMC"):
        check_elemSystem(name_source, self.system, self.clog, extern=True)
        currents = calcCurrents(fields, self.system[name_source], mode)
        return currents

    ##
    # Instantiate a PO propagation. 
    #
    # Stores desired output in the internal fields and/or internal currents dictionary.
    # If the 'EHP' mode is selected, the reflected Poynting frame is stored in the internal frame dictionary.
    #
    # @ingroup public_api_po
    #
    # @param PODict Dictionary containing the PO propagation instructions.
    #
    # @see PODict
    def runPO(self, runPODict):
        self.clog.work("*** Starting PO propagation ***")
       
        check_runPODict(runPODict, self.system.keys(), self.fields.keys(), self.currents.keys(),
                    self.scalarfields.keys(), self.frames.keys(), self.clog)

        _runPODict = self.copyObj(runPODict)

        if _runPODict["mode"] != "scalar":
            sc_name = _runPODict["s_current"]
            _runPODict["s_current"] = self.currents[_runPODict["s_current"]]
            self.clog.work(f"Propagating {sc_name} on {_runPODict['s_current'].surf} to {_runPODict['t_name']}, propagation mode: {_runPODict['mode']}.")
            source = self.system[_runPODict["s_current"].surf]
            _runPODict["k"] = _runPODict["s_current"].k

        else:
            sc_name = _runPODict["s_scalarfield"]
            _runPODict["s_scalarfield"] = self.scalarfields[_runPODict["s_scalarfield"]]
            self.clog.work(f"Propagating {sc_name} on {_runPODict['s_scalarfield'].surf} to {_runPODict['t_name']}, propagation mode: {_runPODict['mode']}.")
            source = self.system[_runPODict["s_scalarfield"].surf]
            _runPODict["k"] = _runPODict["s_scalarfield"].k
       

        target = self.system[_runPODict["t_name"]]
        
        start_time = time.time()
        
        if _runPODict["device"] == "CPU":
            self.clog.work(f"Hardware: running {_runPODict['nThreads']} CPU threads.")
            self.clog.work(f"... Calculating ...")
            out = PyPO_CPUd(source, target, _runPODict)

        elif _runPODict["device"] == "GPU":
            self.clog.work(f"Hardware: running {_runPODict['nThreads']} CUDA threads per block.")
            self.clog.work(f"... Calculating ...")
            out = PyPO_GPUf(source, target, _runPODict)

        dtime = time.time() - start_time
        
        if _runPODict["mode"] == "JM":
            out.setMeta(_runPODict["t_name"], _runPODict["k"])
            self.currents[_runPODict["name_JM"]] = out
        
        elif _runPODict["mode"] == "EH" or _runPODict["mode"] == "FF":
            out.setMeta(_runPODict["t_name"], _runPODict["k"])
            self.fields[_runPODict["name_EH"]] = out
        
        elif _runPODict["mode"] == "JMEH":
            out[0].setMeta(_runPODict["t_name"], _runPODict["k"])
            out[1].setMeta(_runPODict["t_name"], _runPODict["k"])
            self.currents[_runPODict["name_JM"]] = out[0]
            self.fields[_runPODict["name_EH"]] = out[1]
        
        elif _runPODict["mode"] == "EHP":
            out[0].setMeta(_runPODict["t_name"], _runPODict["k"])
            self.fields[_runPODict["name_EH"]] = out[0]

            frame = self._loadFramePoynt(out[1], _runPODict["t_name"])
            self.frames[_runPODict["name_P"]] = frame
       
            self.assoc[_runPODict["t_name"]] = [_runPODict["name_EH"], _runPODict["name_P"]]

        elif _runPODict["mode"] == "scalar":
            out.setMeta(_runPODict["t_name"], _runPODict["k"])
            self.scalarfields[_runPODict["name_field"]] = out

        self.clog.work(f"*** Finished: {dtime:.3f} seconds ***")
        return out

    ##
    # Merge multiple beams that are defined on the same surface.
    #
    # The beams to be merged are first checked to see if they are all defined on the same surface.
    # Then, a new PO field or current is defined in the internal dictionary with the new name.
    #
    # @ingroup public_api_po
    #
    # @param beams Fields or currents objects to merge.
    # @param obj Whether the beams are PO fields or currents.
    # @param merged_name Name of merged object.
    def mergeBeams(self, *beams, obj="fields", merged_name="combined"):
        check_sameBound(beams, checkDict=getattr(self, obj), clog=self.clog) 
        ex = getattr(self, obj)[beams[0]]

        x1 = np.zeros(ex[0].shape, dtype=complex)
        x2 = np.zeros(ex[0].shape, dtype=complex)
        x3 = np.zeros(ex[0].shape, dtype=complex)
        
        y1 = np.zeros(ex[0].shape, dtype=complex)
        y2 = np.zeros(ex[0].shape, dtype=complex)
        y3 = np.zeros(ex[0].shape, dtype=complex)
        
        for beam in beams:
            if obj == "fields":
                check_fieldSystem(beam, self.fields, self.clog, extern=True)
            if obj == "currents":
                check_currentSystem(beam, self.currents, self.clog, extern=True)
            
            beam = getattr(self, obj)[beam]
            x1 += beam[0]
            x2 += beam[1]
            x3 += beam[2]
            
            y1 += beam[3]
            y2 += beam[4]
            y3 += beam[5]

        if obj == "fields":
            field = fields(x1, x2, x3, y1, y2, y3)
        if obj == "currents":
            field = currents(x1, x2, x3, y1, y2, y3)
        
        field.setMeta(ex.surf, ex.k)
        getattr(self, obj)[merged_name] = field

    ##
    # Create a tube of rays from a TubeRTDict.
    #
    # The tube of rays will be placed in the internal frame dictionary. 
    # Position and orientation trackers for the frame are initialised to the origin and z-axis, respectively.
    #
    # @ingroup public_api_frames
    #
    # @param argDict A TubeRTDict, filled. If not filled properly, will raise an exception.
    #
    # @see TubeRTDict
    def createTubeFrame(self, argDict):
        if not argDict["name"]:
            argDict["name"] = f"Frame"
        _argDict = self.copyObj(argDict) 
        check_TubeRTDict(_argDict, self.frames.keys(), self.clog)
        
        self.frames[_argDict["name"]] = makeRTframe(_argDict)

        self.frames[_argDict["name"]].setMeta(self.copyObj(world.ORIGIN()), self.copyObj(world.IAX()), self.copyObj(world.INITM()))

        self.clog.info(f"Added tubular frame {_argDict['name']} to system.")
    
    ##
    # Create a Gaussian beam distribution of rays from a GRTDict.
    #
    # The Gaussian frame will be placed in the internal frame dictionary.
    # The frame is generated by rejection-sampling a Gaussian distribution in position and direction on an xy-grid.
    # Position and orientation trackers for the frame are initialised to the origin and z-axis, respectively.
    #
    # @ingroup public_api_frames
    #
    # @param argDict A GRTDict, filled. If not filled properly, will raise an exception.
    #
    # @see GRTDict
    def createGRTFrame(self, argDict): 
        if not argDict["name"]:
            argDict["name"] = f"Frame"
        
        _argDict = self.copyObj(argDict) 
        check_GRTDict(_argDict, self.frames.keys(), self.clog)
        
        self.clog.work(f"Generating Gaussian ray-trace beam.")
        self.clog.work(f"... Sampling ...")
       
        start_time = time.time()
        _argDict["angx0"] = np.degrees(_argDict["lam"] / (np.pi * _argDict["n"] * _argDict["x0"]))
        _argDict["angy0"] = np.degrees(_argDict["lam"] / (np.pi * _argDict["n"] * _argDict["y0"]))

        #check_RTDict(_argDict, self.frames.keys())
        self.frames[_argDict["name"]] = makeGRTframe(_argDict)
        self.frames[_argDict["name"]].setMeta(self.copyObj(world.ORIGIN()), self.copyObj(world.IAX()), self.copyObj(world.INITM()))
        
        dtime = time.time() - start_time
        self.clog.work(f"Succesfully sampled {_argDict['nRays']} rays: {dtime} seconds.")
        self.clog.info(f"Added Gaussian frame {_argDict['name']} to system.")

    ##
    # Calculate total length of a ray-trace beam.
    #
    # Takes multiple frames and calculates the distance for each ray between frames.
    # If the "start" parameter is set to a len-3 Numpy array, the ray length will also include the 
    # distance between the position of the ray in the first frame and the given starting point.
    # This is useful in case the rays emanate from a single point which is not included as a frame in the internal dictionary.
    #
    # @ingroup public_api_frames
    #
    # @param frames Frames between which to calculate total pathlength.
    # @param start Point from which to start the calculation, len-3 Numpy array. If given, also calculates distance between point and the first frame. Defaults to None.
    #
    # @returns out List containing the distances between frames. Can be summed over to obtain total distance.
    def calcRayLen(self, *frames, start=None):
        for fr in frames:
            check_frameSystem(fr, self.frames, self.clog, extern=True)

        if isinstance(start, np.ndarray):
            frame0 = self.frames[frames[0]]

            out = []
            sumd = np.zeros(len(frame0.x))

            diffx = frame0.x - start[0]
            diffy = frame0.y - start[1]
            diffz = frame0.z - start[2]

            lens = np.sqrt(diffx**2 + diffy**2 + diffz**2)
            out.append(lens)

            sumd += lens

            for i in range(len(frames) - 1):
                diffx = self.frames[frames[i+1]].x - frame0.x
                diffy = self.frames[frames[i+1]].y - frame0.y
                diffz = self.frames[frames[i+1]].z - frame0.z

                lens = np.sqrt(diffx**2 + diffy**2 + diffz**2)
                out.append(lens)

                frame0 = self.frames[frames[i+1]]
                sumd += lens

            out.append(sumd)

        else:
            frame0 = self.frames[frames[0]]

            out = []
            sumd = np.zeros(len(frame0.x))

            for i in range(len(frames) - 1):
                diffx = self.frames[frames[i+1]].x - frame0.x
                diffy = self.frames[frames[i+1]].y - frame0.y
                diffz = self.frames[frames[i+1]].z - frame0.z

                lens = np.sqrt(diffx**2 + diffy**2 + diffz**2)
                out.append(lens)

                frame0 = self.frames[frames[i+1]]
                sumd += lens

            out.append(sumd)

        return out

    ##
    # Create a vectorial Gaussian beam.
    #
    # This method creates a general, potentially astigmatic, vectorial Gaussian beam.
    # The beam is evaluated with the focus at z = 0. 
    # The surface on which the beam is calculated, defined by "name_source", does not have to lie in or be parallel to the xy-plane.
    # Instead, the Gaussian beam is evaluated on the surface as-is, evaluating the Gaussian beam at the xyz-points on the surface.
    # Still, the focus is at z = 0. If one wishes to displace the focal point, the PO fields and currents need to be translated after generating the Gaussian beam.
    #
    # @ingroup public_api_po
    #
    # @param gaussDict A GDict containing parameters for the Gaussian beam.
    # @param name_surface Name of plane on which to define Gaussian.
    #
    # @see GDict
    def createGaussian(self, gaussDict, name_surface):
        check_elemSystem(name_surface, self.system, self.clog, extern=True)

        _gaussDict = self.copyObj(gaussDict)
        check_GPODict(_gaussDict, self.fields, self.clog)
        
        gauss_in = makeGauss(_gaussDict, self.system[name_surface])

        k = 2 * np.pi / _gaussDict["lam"]
        gauss_in[0].setMeta(name_surface, k)
        gauss_in[1].setMeta(name_surface, k)

        self.fields[_gaussDict["name"]] = gauss_in[0]
        self.currents[_gaussDict["name"]] = gauss_in[1]
        #return gauss_in
    
    ##
    # Create a scalar Gaussian beam.
    #
    # This method creates a general, potentially astigmatic, scalar Gaussian beam.
    # The beam is evaluated with the focus at z = 0. 
    # The surface on which the beam is calculated, defined by "name_source", does not have to lie in or be parallel to the xy-plane.
    # Instead, the Gaussian beam is evaluated on the surface as-is, evaluating the Gaussian beam at the xyz-points on the surface.
    # Still, the focus is at z = 0. If one wishes to displace the focal point, the PO scalarfield needs to be translated after generating the Gaussian beam.
    #
    # @ingroup public_api_po
    #
    # @param gaussDict A GDict containing parameters for the Gaussian beam.
    # @param name_surface Name of plane on which to define Gaussian.
    #
    # @see SGDict
    def createScalarGaussian(self, gaussDict, name_surface):
        check_elemSystem(name_surface, self.system, self.clog, extern=True)
        
        _gaussDict = self.copyObj(gaussDict)
        check_GPODict(_gaussDict, self.scalarfields, self.clog)
        
        gauss_in = makeScalarGauss(_gaussDict, self.system[name_surface])

        k = 2 * np.pi / _gaussDict["lam"]
        gauss_in.setMeta(name_surface, k)

        self.scalarfields[_gaussDict["name"]] = gauss_in

    ##
    # Run a ray-trace propagation from a frame to a surface.
    #
    # The resulting frame is placed in the internal frames dictionary.
    #
    # @ingroup public_api_frames
    #
    # @param runRTDict A runRTDict object specifying the ray-trace.
    def runRayTracer(self, runRTDict):
        self.clog.work("*** Starting RT propagation ***")
        
        _runRTDict = self.copyObj(runRTDict)

        check_runRTDict(_runRTDict, self.system, self.frames, self.clog)

        _runRTDict["fr_in"] = self.frames[_runRTDict["fr_in"]]
        _runRTDict["t_name"] = self.system[_runRTDict["t_name"]]

        start_time = time.time()
       
        if _runRTDict["device"] == "CPU":
            self.clog.work(f"Hardware: running {_runRTDict['nThreads']} CPU threads.")
            self.clog.work(f"... Calculating ...")
            frameObj = RT_CPUd(_runRTDict)

        elif _runRTDict["device"] == "GPU":
            self.clog.work(f"Hardware: running {_runRTDict['nThreads']} CUDA threads per block.")
            self.clog.work(f"... Calculating ...")
            frameObj = RT_GPUf(_runRTDict)
        
        dtime = time.time() - start_time
        
        self.clog.work(f"*** Finished: {dtime:.3f} seconds ***")
        self.frames[runRTDict["fr_out"]] = frameObj
        
        self.frames[runRTDict["fr_out"]].setMeta(self.calcRTcenter(runRTDict["fr_out"]), self.calcRTtilt(runRTDict["fr_out"]), self.copyObj(world.INITM()))
    
    ##
    # Perform a hybrid RT/PO propagation, starting from a reflected field and set of Poynting vectors.
    #
    # The propagation is done by performing a ray trace from the starting frame into the target surface.
    # Then, the starting reflected field is propagated to the target by multiplying each point on the field by the 
    # phase factor corresponding to the travel length of the Poynting vector ray associated to the point on the field.
    # Stores name of resultant field and frame in the internal association dictionary as two associated objects.
    # The name of the association is the surface on which both the target frame and field are defined.
    #
    # @ingroup public_api_hybrid
    #
    # @param hybridDict A hybridDict dictionary.
    def runHybridPropagation(self, hybridDict):
        self.clog.work("*** Starting hybrid propagation ***")
        start_time = time.time()

        check_hybridDict(hybridDict, self.system, self.frames, self.fields, self.clog)
        surf = self.fields[hybridDict["field_in"]].surf
        check_associations(self.assoc, hybridDict["field_in"], hybridDict["fr_in"], surf, self.clog)

        field = self.copyObj(self.fields[hybridDict["field_in"]])

        runRTDict = {
                "fr_in"     : hybridDict["fr_in"],
                "t_name"    : hybridDict["t_name"],
                "fr_out"    : hybridDict["fr_out"],
                "device"    : "CPU"
                }

        verbosity_init = self.verbosity

        self.setLoggingVerbosity(verbose=False)
        self.runRayTracer(runRTDict)
        self.setLoggingVerbosity(verbose=verbosity_init)

        stack = self.calcRayLen(hybridDict["fr_in"], hybridDict["fr_out"], start=hybridDict["start"])
        if hybridDict["start"] is not None:
            expo = np.exp(1j * field.k * stack[1]) * np.sqrt(stack[0] / (2*stack[1] + stack[0])) # Initial curvature

        else:
            expo = np.exp(1j * field.k * stack[0])

        _comps = []
        for i in range(6):
            _comps.append((expo * field[i].ravel()).reshape(field[i].shape))

        field_prop = fields(*_comps)
        field_prop.setMeta(hybridDict["t_name"], field.k)

        self.fields[hybridDict["field_out"]] = field_prop

        if hybridDict["interp"]:
            self.interpFrame(hybridDict["fr_out"], hybridDict["field_out"], hybridDict["t_name"], hybridDict["field_out"], comp=hybridDict["comp"])
        
        dtime = time.time() - start_time

        self.assoc[hybridDict["t_name"]] = [hybridDict["field_out"], hybridDict["fr_out"]]
        self.clog.work(f"*** Finished: {dtime:.3f} seconds ***")

    ##
    # Interpolate a frame and an associated field on a regular surface.
    #
    # The surface should be the target on which the input frame is calculated.
    # The "name_field" should be an associated field, calculated in the same hybrid propagation as "name_fr_in".
    # 
    # @ingroup public_api_hybrid
    #
    # @param name_fr_in Name of input frame.
    # @param name_field Name of field object, propagated along with the frame by multiplication.
    # @param name_target Name of surface on which to interpolate the field.
    # @param name_out Name of output field object in target surface.
    # @param comp Component of field to interpolate. If scalar, leave as is.
    # @param method Method for the interpolation.
    #
    # @returns out Complex numpy array containing interpolated field.
    def interpFrame(self, name_fr_in, name_field, name_target, name_out, comp=None, method="nearest"):
        check_frameSystem(name_fr_in, self.frames, self.clog, extern=True)
        check_elemSystem(name_target, self.system, self.clog, extern=True)
        
        grids = generateGrid(self.system[name_target])

        points = (self.frames[name_fr_in].x, self.frames[name_fr_in].y, self.frames[name_fr_in].z)

        if comp is None:
            _comps = []
            for i in range(6):
                rfield = np.real(self.fields[name_field][i]).ravel()
                ifield = np.imag(self.fields[name_field][i]).ravel()

                grid_interp = (grids.x, grids.y, grids.z)

                rout = griddata(points, rfield, grid_interp, method=method)
                iout = griddata(points, ifield, grid_interp, method=method)

                _comps.append(rout.reshape(self.system[name_target]["gridsize"]) + 1j * iout.reshape(self.system[name_target]["gridsize"]))

            field = fields(*_comps)
            field.setMeta(name_target, self.fields[name_field].k)
            self.fields[name_out] = field

            out = field
       
        else:
            rfield = np.real(getattr(self.fields[name_field], comp)).ravel()
            ifield = np.imag(getattr(self.fields[name_field], comp)).ravel()

            grid_interp = (grids.x, grids.y, grids.z)

            rout = griddata(points, rfield, grid_interp, method=method)
            iout = griddata(points, ifield, grid_interp, method=method)

            out = rout.reshape(self.system[name_target]["gridsize"]) + 1j * iout.reshape(self.system[name_target]["gridsize"])

            field = self._compToFields(comp, out)
            field.setMeta(name_target, self.fields[name_field].k)

            self.fields[name_out] = field 

        return out

    ##
    # Calculate the geometric center of a ray-trace frame.
    #
    # The center is calculated by finding the centroid of the given frame.
    #
    # @ingroup public_api_frames
    #
    # @param name_frame Name of frame to calculate center of.
    #
    # @returns c_f Len-3 Numpy array containing x, y and z co-ordinates of frame center.
    def calcRTcenter(self, name_frame):
        check_frameSystem(name_frame, self.frames, self.clog, extern=True)
        frame = self.frames[name_frame]
        c_f = effs.calcRTcenter(frame)
        return c_f

    ##
    # Calculate the mean direction normal of a ray-trace frame.
    #
    # The mean direction is calculated by taking the mean tilt of every ray in the frame.
    #
    # @ingroup public_api_frames
    #
    # @param name_frame Name of frame to calculate tilt of.
    #
    # @returns t_f Len-3 Numpy array containing x, y and z components of frame tilt direction.
    def calcRTtilt(self, name_frame):
        check_frameSystem(name_frame, self.frames, self.clog, extern=True)
        frame = self.frames[name_frame]
        t_f = effs.calcRTtilt(frame)
        return t_f
    
    ##
    # Calculate the RMS spot size of a ray-trace frame.
    #
    # The RMS spotsize is calculated by taking the root-mean-square of the positions of the rays in the frame.
    #
    # @ingroup public_api_frames
    #
    # @param name_frame Name of frame to calculate RMS of.
    #
    # @returns rms RMS spot size of frame in mm.
    def calcSpotRMS(self, name_frame):
        check_frameSystem(name_frame, self.frames, self.clog, extern=True)
        frame = self.frames[name_frame]
        rms = effs.calcRMS(frame)
        return rms

    ##
    # Calculate spillover efficiency of a beam defined on a surface.
    #
    # The method calculates the spillover using the fraction of the beam that illuminates the region defined in aperDict versus the total beam.
    #
    # @ingroup public_api_po
    #
    # @param name_field Name of the PO field.
    # @param comp Component of field to calculate spillover of.
    # @param aperDict An aperDict dictionary containing the parameters for defining the spillover aperture.
    #
    # @returns spill The spillover efficiency.
    #
    # @see aperDict
    def calcSpillover(self, name_field, comp, aperDict):
        check_fieldSystem(name_field, self.fields, self.clog, extern=True)
        check_aperDict(aperDict, self.clog)

        field = self.fields[name_field]
        field_comp = getattr(field, comp)
        surfaceObj = self.system[field.surf]

        return effs.calcSpillover(field_comp, surfaceObj, aperDict)

    ##
    # Calculate taper efficiency of a beam defined on a surface.
    #
    # The method calculates the taper efficiency using the fraction of the beam that illuminates the region defined in aperDict versus the total beam.
    # If aperDict is not given, it will calculate the taper efficiency on the entire beam.
    #
    # @ingroup public_api_po
    #
    # @param name_field Name of the PO field.
    # @param comp Component of field to calculate taper efficiency of.
    # @param aperDict An aperDict dictionary containing the parameters for defining the taper aperture. Defaults to None.
    #
    # @returns taper The taper efficiency.
    #
    # @see aperDict
    def calcTaper(self, name_field, comp, aperDict=None):
        check_fieldSystem(name_field, self.fields, self.clog, extern=True)
        aperDict = {} if aperDict is None else aperDict

        if aperDict:
            check_aperDict(aperDict, self.clog)

        field = self.fields[name_field]
        field_comp = getattr(field, comp)
        surfaceObj = self.system[field.surf]

        return effs.calcTaper(field_comp, surfaceObj, aperDict)

    ##
    # Calculate cross-polar efficiency of a field defined on a surface.
    #
    # The cross-polar efficiency is calculated over the entire field extent.
    #
    # @ingroup public_api_po
    #
    # @param name_field Name of the PO field.
    # @param comp_co Co-polar component of field.
    # @param comp_cr Cross-polar component of field.
    #
    # @returns crp The cross-polar efficiency.
    def calcXpol(self, name_field, comp_co, comp_cr):
        check_fieldSystem(name_field, self.fields, self.clog, extern=True)
        field = self.fields[name_field]
        field_co = getattr(field, comp_co)
        
        field_cr = getattr(field, comp_cr)
        
        return effs.calcXpol(field_co, field_cr)

    ##
    # Fit a Gaussian profile to the amplitude of a field component and adds the result to scalar field in system.
    #
    # The resultant Gaussian fit cannot be propagated using vectorial means, but can be propagated using scalar propagation.
    # Note that this method is very sensitive to initial conditions, especially when the beam pattern to which to fit the Gaussian has multiple maxima or is generally
    # ill-described by a Gaussian. In the latter case, the method may fail altogether.
    #
    # @ingroup public_api_po
    #
    # @param name_field Name of field object.
    # @param comp Component of field object.
    # @param thres Threshold to fit to, in decibels.
    # @param mode Fit to amplitude in decibels, linear or logarithmically.
    # @param full_output Return fitted parameters and standard deviations.
    #
    # @returns popt Fitted beam parameters.
    # @returns perr Standard deviation of fitted parameters.
    def fitGaussAbs(self, name_field, comp, thres=None, mode=None, full_output=False, ratio=1):
        check_fieldSystem(name_field, self.fields, self.clog, extern=True)

        thres = -11 if thres is None else thres
        mode = "linear" if mode is None else mode

        surfaceObj = self.system[self.fields[name_field].surf]
        field = self.copyObj(np.absolute(getattr(self.fields[name_field], comp)))

        popt, perr = fgs.fitGaussAbs(field, surfaceObj, thres, mode, ratio)

        Psi = scalarfield(fgs.generateGauss(popt, surfaceObj, mode="linear"))
        Psi.setMeta(self.fields[name_field].surf, self.fields[name_field].k)
       
        _name = f"fitGauss_{name_field}"

        num = getIndex(_name, self.scalarfields)
        
        if num > 0:
            _name = _name + "_{}".format(num)

        self.scalarfields[_name] = Psi

        if full_output:
            return popt, perr

    ##
    # Calculate main-beam efficiency of a beam pattern.
    #
    # The main-beam efficiency is calculated by fitting a Gaussian amplitude profile to the central lobe.
    # This might reuire fine-tuning the "thres" parameter, or changing the space in whcih to fit by supplying the "mode" parameter.
    # Then, the efficiency is defined as the fraction of power in the Gaussian w.r.t. the full pattern.
    # Designed for far-field beam patterns, but also applicable to regular fields.
    # Note that since this method uses the fitGaussAbs() method, the result is quite sensitive to initial conditions and should therefore be (iteratively) checked for 
    # robustness.
    #
    # @ingroup public_api_po
    #
    # @param name_field Name of field object.
    # @param comp Component of field object.
    # @param thres Threshold to fit to, in decibels.
    # @param mode Fit to amplitude in decibels, linear or logarithmically.
    #
    # @returns eff Main-beam efficiency.
    def calcMainBeam(self, name_field, comp, thres=None, mode=None):
        check_fieldSystem(name_field, self.fields, self.clog, extern=True)
        thres = -11 if thres is None else thres
        mode = "linear" if mode is None else mode

        _thres = self.copyObj(thres)

        self.fitGaussAbs(name_field, comp, thres, mode)
        field = self.copyObj(getattr(self.fields[name_field], comp))
        surfaceObj = self.system[self.fields[name_field].surf]
        
        eff = effs.calcMainBeam(field, surfaceObj, self.scalarfields[f"fitGauss_{name_field}"].S)
        return eff
    
    ##
    # Calculate cross sections of a beam pattern.
    #
    # This method calculates cross sections along the cardinal planes of the beam pattern.
    # The cardinal planes here are defined to lie along the semi-major and semi-minor axes of the beam pattern.
    # It does this by first finding the center and position angle of the beam pattern.
    # Then, it creates a snapshot of the current configuration and translates and rotates the beam pattern so that the cardinal planes are 
    # oriented along the x- and y-axes.
    # It is also possible to not do this and instead directly calculate the cross sections along the x- and y-axes as-is.
    #
    # @ingroup public_api_po
    #
    # @param name_field Name of field object.
    # @param comp Component of field object.
    # @param phi Manual rotation of cuts w.r.t. to the x-y cardinal planes.
    # @param center Whether to center the cardinal planes on the peak of the beam pattern.
    # @param align Whether to align the cardinal planes to the beam pattern minor and major axes.
    # @param norm Which component to normalise to. Defaults to comp. 
    #
    # @returns x_cut Beam cross section along the E-plane.
    # @returns y_cut Beam cross section along the H-plane.
    # @returns x_strip Co-ordinate values for x_cut.
    # @returns y_strip Co-ordinate values for y_cut.
    def calcBeamCuts(self, name_field, comp, phi=0, center=True, align=True, norm=False):
        check_fieldSystem(name_field, self.fields, self.clog, extern=True)
 
        verbosity_init = self.verbosity

        self.setLoggingVerbosity(verbose=False)

        name_surf = self.fields[name_field].surf
        field = np.absolute(getattr(self.fields[name_field], comp))
        _field = self.copyObj(self.fields[name_field])

        self.snapObj(name_surf, "__pre")

        if center or align:
            popt, perr = self.fitGaussAbs(name_field, comp, mode="linear", full_output=True)
        
        if center:
            self.translateGrids(name_surf, np.array([-popt[2], -popt[3], 0]))
        
        grids_orig = self.generateGrids(name_surf, spheric=False)
            
        
        if align:
            if popt[0] > popt[1]:
                angf = 90
            else:
                angf = 0
            
            if align:
                self.rotateGrids(name_surf, np.array([0, 0, angf + np.degrees(-popt[4])]), pivot=world.ORIGIN(), keep_pol=False)
        

        self.rotateGrids(name_surf, np.array([0, 0, phi]), pivot=world.ORIGIN(), keep_pol=False)

        grids_transf = self.generateGrids(name_surf, spheric=False)
        
        middle = lambda x: [int(np.floor(d/2)) for d in x.shape]
        idx_c = np.argwhere(np.isclose(grids_transf.x, 0) & np.isclose(grids_transf.y, 0))
        idx_c = np.unravel_index(np.argmax(field), field.shape)
        if not norm:
            x_cut = self.copyObj(20 * np.log10(field[:, idx_c[1]] / np.max(field)))
            y_cut = self.copyObj(20 * np.log10(field[idx_c[0], :] / np.max(field)))
        
        else:
            x_cut = self.copyObj(20 * np.log10(field[:, idx_c[1]] / np.max(np.absolute(getattr(self.fields[name_field], norm)))))
            y_cut = self.copyObj(20 * np.log10(field[idx_c[0], :] / np.max(np.absolute(getattr(self.fields[name_field], norm)))))

        x_strip = self.copyObj(grids_orig.x[:, idx_c[1]])
        y_strip = self.copyObj(grids_orig.y[idx_c[0], :])

        self.revertToSnap(name_surf, "__pre")
        self.deleteSnap(name_surf, "__pre")

        self.setLoggingVerbosity(verbose=verbosity_init)
        self.fields[name_field] = _field

        return x_cut, y_cut, x_strip, y_strip
   
    ##
    # Plot beam pattern cross sections.
    #
    # Plot the beam cross sections for a PO field.
    # In this case, calcBeamCuts() will try to translate and rotate the supplied beam pattern to lie along the x- and y-axes.
    #
    # @ingroup public_api_vis
    #
    # @param name_field Name of field object.
    # @param comp Component of field object.
    # @param comp_cross Cross-polar component. If given, is plotted as well. Defaults to None.
    # @param vmin Minimum amplitude value to display. Default is -30.
    # @param vmax Maximum amplitude value to display. Default is 0.
    # @param units The units of the axes. Default is "", which is degrees.
    # @param name Name of .png file where plot is saved. Only when save=True. Default is "".
    # @param show Show plot. Default is True.
    # @param save Save plot to savePath.
    # @param ret Return the Figure and Axis object. Only called by GUI. Default is False.
    #
    # @returns fig Figure object.
    # @returns ax Axes object.
    def plotBeamCut(self, name_field, comp, comp_cross=None, vmin=None, vmax=None, units='', name="", show=True, save=False, ret=False):
        E_cut, H_cut, E_strip, H_strip = self.calcBeamCuts(name_field, comp)

        #if comp_cross is not None:
            #cr45_cut, cr135_cut, cr45_strip, cr135_strip = self.calcBeamCuts(name_field, comp_cross, phi=45, align=False, center=False, norm="Ex")

        default = "deg"

        unitl = self._units(units, default)

        vmin = np.min([np.min(E_cut), np.min(H_cut)]) if vmin is None else vmin
        vmax = np.max([np.max(E_cut), np.max(H_cut)]) if vmax is None else vmax
        
        fig, ax = plt.plotBeamCut(E_cut, H_cut, E_strip, H_strip, vmin, vmax, unitl)

        if ret:
            return fig, ax

        elif save:
            pt.savefig(fname=self.savePath + '{}_EH_cut.jpg'.format(name),
                        bbox_inches='tight', dpi=300)
            pt.close()

        elif show:
            pt.show()

    ##
    # Calculate half-power beamwidth.
    #
    # This is done by directly evaluating the -3 dB points along both cardinal planes of the beam pattern.
    # Then, the distance between antipodal half-power points is calculated on an interpolation of the supplied PO field.
    #
    # @ingroup public_api_po
    #
    # @param name_field Name of field object.
    # @param comp Component of field object.
    # @param interp Interpolation factor for finding the HPBW. Defaults to 50.
    #
    # @returns HPBW_E Half-power beamwidth along E-plane.
    # @returns HPBW_H Half-power beamwidth along H-plane.
    def calcHPBW(self, name_field, comp, interp=50):
        x_cut, y_cut, x_strip, y_strip = self.calcBeamCuts(name_field, comp)#, center=False, align=False)

        x_interp = np.linspace(np.min(x_strip), np.max(x_strip), num=len(x_strip) * interp)
        y_interp = np.linspace(np.min(y_strip), np.max(y_strip), num=len(y_strip) * interp)

        x_cut_interp = interp1d(x_strip, x_cut, kind="cubic")(x_interp)
        y_cut_interp = interp1d(y_strip, y_cut, kind="cubic")(y_interp)

        mask_x = (x_cut_interp > -3.01) & (x_cut_interp < -2.99)
        mask_y = (y_cut_interp > -3.01) & (y_cut_interp < -2.99)

        HPBW_E = np.mean(np.absolute(x_interp[mask_x])) * 2 * 3600
        HPBW_H = np.mean(np.absolute(y_interp[mask_y])) * 2 * 3600

        return HPBW_E, HPBW_H

    ##
    # Generate point-source PO fields and currents.
    #
    # The point source is generated in the center of the source surface given by "name_surface".
    # It is generally a good idea to make this source surface as small as possible, in order to create a "nice" point source.
    # If this is too big, the resulting PO field more closely resembles a uniformly illuminated square.
    # The H-field is set to 0.
    #
    # @ingroup public_api_po
    #
    # @param PSDict A PSDict dictionary, containing parameters for the point source.
    # @param name_surface Name of surface on which to define the point-source.
    #
    # @see PSDict
    def createPointSource(self, PSDict, name_surface):
        check_elemSystem(name_surface, self.system, self.clog, extern=True)
        _PSDict = self.copyObj(PSDict)
        check_PSDict(_PSDict, self.fields, self.clog)

        surfaceObj = self.system[name_surface]
        ps = np.zeros(surfaceObj["gridsize"], dtype=complex)

        xs_idx = int((surfaceObj["gridsize"][0] - 1) / 2)
        ys_idx = int((surfaceObj["gridsize"][1] - 1) / 2)

        ps[xs_idx, ys_idx] = _PSDict["E0"] * np.exp(1j * _PSDict["phase"])

        Ex = ps * _PSDict["pol"][0]
        Ey = ps * _PSDict["pol"][1]
        Ez = ps * _PSDict["pol"][2]

        Hx = ps * 0
        Hy = ps * 0
        Hz = ps * 0

        field = fields(Ex, Ey, Ez, Hx, Hy, Hz) 
        current = self.calcCurrents(name_surface, field)

        k =  2 * np.pi / _PSDict["lam"]

        field.setMeta(name_surface, k)
        current.setMeta(name_surface, k)

        self.fields[_PSDict["name"]] = field
        self.currents[_PSDict["name"]] = current

    ##
    # Generate uniform PO fields and currents.
    #
    # The uniform field is generated by defining a PO field on the source surface and setting all values to the amplitude specified in 
    # the input dictionary. The H-field is set to 0.
    #
    # @ingroup public_api_po
    #
    # @param UDict A UDict dictionary, containing parameters for the uniform pattern.
    # @param name_surface Name of surface on which to define the uniform pattern.
    #
    # @see PSDict
    def createUniformSource(self, UDict, name_surface):
        check_elemSystem(name_surface, self.system, self.clog, extern=True)
        _UDict = self.copyObj(UDict)
        check_PSDict(_UDict, self.fields, self.clog)

        surfaceObj = self.system[name_surface]
        us = np.ones(surfaceObj["gridsize"], dtype=complex) * _UDict["E0"] * np.exp(1j * _UDict["phase"])

        Ex = us * _UDict["pol"][0]
        Ey = us * _UDict["pol"][1]
        Ez = us * _UDict["pol"][2]

        Hx = us * 0
        Hy = us * 0
        Hz = us * 0

        field = fields(Ex, Ey, Ez, Hx, Hy, Hz) 
        current = self.calcCurrents(name_surface, field)

        k =  2 * np.pi / _UDict["lam"]

        field.setMeta(name_surface, k)
        current.setMeta(name_surface, k)

        self.fields[_UDict["name"]] = field
        self.currents[_UDict["name"]] = current
    
    ##
    # Generate point-source scalar PO field.
    #
    # The point source is generated in the center of the source surface given by "name_surface".
    # It is generally a good idea to make this source surface as small as possible, in order to create a "nice" point source.
    # If this is too big, the resulting PO field more closely resembles a uniformly illuminated square.
    # The H-field is set to 0.
    #
    # @ingroup public_api_po
    #
    # @param PSDict A PSDict dictionary, containing parameters for the point source.
    # @param name_surface Name of surface on which to define the point-source.
    #
    # @see PSDict
    def createPointSourceScalar(self, PSDict, name_surface):
        check_elemSystem(name_surface, self.system, self.clog, extern=True)
        
        _PSDict = self.copyObj(PSDict)
        check_PSDict(_PSDict, self.scalarfields, self.clog)
        
        surfaceObj = self.system[name_surface]
        ps = np.zeros(surfaceObj["gridsize"], dtype=complex)

        xs_idx = int((surfaceObj["gridsize"][0] - 1) / 2)
        ys_idx = int((surfaceObj["gridsize"][1] - 1) / 2)

        ps[xs_idx, ys_idx] = _PSDict["E0"] * np.exp(1j * _PSDict["phase"])
        sfield = scalarfield(ps)

        k =  2 * np.pi / _PSDict["lam"]

        sfield.setMeta(name_surface, k)

        self.scalarfields[_PSDict["name"]] = sfield
    
    ##
    # Generate scalar uniform PO fields and currents.
    #
    # The uniform field is generated by defining a PO field on the source surface and setting all values to the amplitude specified in 
    # the input dictionary. The H-field is set to 0.
    #
    # @ingroup public_api_po
    #
    # @param UDict A UDict dictionary, containing parameters for the uniform pattern.
    # @param name_surface Name of surface on which to define the uniform pattern.
    #
    # @see UDict
    def createUniformSourceScalar(self, UDict, name_surface):
        check_elemSystem(name_surface, self.system, self.clog, extern=True)
        _UDict = self.copyObj(UDict)
        check_PSDict(_UDict, self.scalarfields, self.clog)

        surfaceObj = self.system[name_surface]
        us = np.ones(surfaceObj["gridsize"], dtype=complex) * _UDict["E0"] * np.exp(1j * _UDict["phase"])

        sfield = scalarfield(us)

        k =  2 * np.pi / _UDict["lam"]

        sfield.setMeta(name_surface, k)

        self.scalarfields[_UDict["name"]] = sfield
   
    ##
    # Interpolate a PO beam. Only for beams defined on planar surfaces.
    #
    # Can interpolate PO fields and currents separately.
    # Results are stored in a new PO fields/currents object with the original name appended by 'interp'.
    # Also, a new plane will be created with the updated gridsize and name appended by 'interp'.
    #
    # @ingroup public_api_po
    #
    # @param name Name of beam to be interpolated.
    # @param gridsize_new New gridsizes for interpolation.
    # @param obj Whether to interpolate currents or fields.
    def interpBeam(self, name, gridsize_new, obj_t="fields"):
        if obj_t == "fields":
            check_fieldSystem(name, self.fields, self.clog, extern=True)
            obj = self.fields[name]

        elif obj_t == "currents":
            check_currentSystem(name, self.currents, self.clog, extern=True)
            obj = self.currents[name]

        self.copyElement(obj.surf, obj.surf + "_interp")
        self.system[obj.surf + "_interp"]["gridsize"] = gridsize_new
        self.system[obj.surf + "_interp"]["name"] = obj.surf + "_interp"

        grids = self.generateGrids(obj.surf)
        grids_interp = self.generateGrids(obj.surf + "_interp")
        
        points = (grids.x.ravel(), grids.y.ravel())#, grids.z.ravel())
        points_interp = (grids_interp.x.ravel(), grids_interp.y.ravel())#, grids_interp.z.ravel())
        comp_l = []

        for i in range(6):
            _comp = self.copyObj(obj[i])
            _cr = np.real(_comp)
            _ci = np.imag(_comp)

            _cr_interp = griddata(points, _cr.ravel(), points_interp)
            _ci_interp = griddata(points, _ci.ravel(), points_interp)
       
            _comp_interp = _cr_interp + 1j * _ci_interp

            comp_l.append(_comp_interp.reshape(gridsize_new))

        if obj_t == "fields":
            obj_interp = fields(comp_l[0], comp_l[1], comp_l[2], comp_l[3], comp_l[4], comp_l[5])
            obj_interp.setMeta(obj.surf + "_interp", obj.k)
            self.fields[name + "_interp"] = obj_interp
        
        elif obj_t == "currents":
            obj_interp = currents(comp_l[0], comp_l[1], comp_l[2], comp_l[3], comp_l[4], comp_l[5])
            obj_interp.setMeta(obj.surf + "_interp", obj.k)
            self.currents[name + "_interp"] = obj_interp

    ##
    # Generate a 2D plot of a PO (scalar)field or current.
    #
    # Note that matplotlib offers custom control over figures in the matplotlib window.
    # This means that most parameters described for this method can be adjusted in the matplotlib plotting window.
    #
    # @ingroup public_api_vis
    #
    # @param name_obj Name of field or current to plot.
    # @param comp Component of field or current to plot. 
    # @param contour A PyPO field or current component to plot as contour.
    # @param contour_comp Component of contour to plot as contour. If None, looks is scalarfields.
    # @param vmin Minimum amplitude value to display. Default is -30.
    # @param vmax Maximum amplitude value to display. Default is 0.
    # @param levels Levels for contourplot.
    # @param show Show plot. Default is True.
    # @param amp_only Only plot amplitude pattern. Default is False.
    # @param save Save plot to /images/ folder.
    # @param interpolation What interpolation to use for displaying amplitude pattern. Default is None.
    # @param norm Normalise field (only relevant when plotting linear scale). Default is True.
    # @param aperDict Plot an aperture defined in an aperDict object along with the field or current patterns. Default is None.
    # @param mode Plot amplitude in decibels ("dB") or on a linear scale ("linear"). Default is "dB".
    # @param project Set abscissa and ordinate of plot. Should be given as a string. Default is "xy".
    # @param units The units of the axes. Default is "", which is millimeters.
    # @param name Name of .png file where plot is saved. Only when save=True. Default is "".
    # @param titleA Title of the amplitude plot. Default is "Amp".
    # @param titleP Title of the phase plot. Default is "Phase".
    # @param unwrap_phase Unwrap the phase patter. Prevents annular structure in phase pattern. Default is False.
    # @param ret Return the Figure and Axis object. Only called by GUI. Default is False.
    #
    # @see aperDict
    def plotBeam2D(self, name_obj, comp=None, contour=None, contour_comp=None,
                    vmin=None, vmax=None, levels=None, show=True, amp_only=False,
                    save=False, interpolation=None, norm=True,
                    aperDict=None, mode='dB', project='xy',
                    units="", name="", titleA="Power", titleP="Phase",
                    unwrap_phase=False, ret=False):

        aperDict = {"plot":False} if aperDict is None else aperDict

        if comp is None:
            field_comp = self.scalarfields[name_obj].S
            name_surface = self.scalarfields[name_obj].surf
        
        elif comp[0] == "E" or comp[0] == "H":
            check_fieldSystem(name_obj, self.fields, self.clog, extern=True)
            field = self.fields[name_obj]
            name_surface = field.surf
        
            if comp in self.EHcomplist:
                field_comp = getattr(field, comp)

        elif comp[0] == "J" or comp[0] == "M":
            check_currentSystem(name_obj, self.currents, self.clog, extern=True)
            field = self.currents[name_obj] 
            name_surface = field.surf
            
            if comp in self.JMcomplist:
                field_comp = getattr(field, comp)
        
        if contour is not None:
            if contour_comp is None:
                contour_pl = self.scalarfields[contour].S
            
            else:
                if contour_comp[0] == "E" or contour_comp[0] == "H":
                    check_fieldSystem(contour, self.fields, self.clog, extern=True)
                    contour_pl = getattr(self.fields[contour], contour_comp)
            
                elif contour_comp[0] == "J" or contour_comp[0] == "M":
                    check_currentSystem(contour, self.currents, self.clog, extern=True)
                    contour_pl = getattr(self.currents[contour], contour_comp)
        else:
            contour_pl = contour

        plotObject = self.system[name_surface]
        
        default = "mm"
        if plotObject["gmode"] == 2 and not units:
            default = "deg"

        unitl = self._units(units, default)
        
        fig, ax = plt.plotBeam2D(plotObject, field_comp, contour_pl,
                        vmin, vmax, levels, show, amp_only,
                        save, interpolation, norm,
                        aperDict, mode, project,
                        unitl, name, titleA, titleP, self.savePath, unwrap_phase)

        if ret:
            return fig, ax

        elif save:
            pt.savefig(fname=self.savePath + '{}_{}.jpg'.format(plotObject["name"], name),
                        bbox_inches='tight', dpi=300)
            pt.close()

        elif show:
            pt.show()

    ##
    # Plot a 3D reflector.
    #
    # Note that matplotlib offers custom control over figures in the matplotlib window.
    # This means that most parameters described for this method can be adjusted in the matplotlib plotting window.
    #
    # @ingroup public_api_vis
    #
    # @param name_surface Name of reflector to plot.
    # @param cmap Colormap of reflector. Default is cool.
    # @param norm Plot reflector normals. Default is False.
    # @param fine Spacing of normals for plotting. Default is 2.
    # @param show Show plot. Default is True.
    # @param foc1 Plot focus 1. Default is False.
    # @param foc2 Plot focus 2. Default is False.
    # @param save Save the plot.
    # @param ret Return Figure and Axis. Only used in GUI.
    def plot3D(self, name_surface, cmap=cm.cool,
            norm=False, fine=2, show=True, foc1=False, foc2=False, save=False, ret=False):
        
        fig, ax = pt.subplots(figsize=(10,10), subplot_kw={"projection": "3d"})
        
        if isinstance(name_surface, list) or isinstance(name_surface, np.ndarray):
            for n_s in name_surface:
                check_elemSystem(n_s, self.system, self.clog, extern=True)
                plotObject = self.system[n_s]
                plt.plot3D(plotObject, ax, fine, cmap, norm, foc1, foc2)
        
        else:
            check_elemSystem(name_surface, self.system, self.clog, extern=True)
            plotObject = self.system[name_surface]
            plt.plot3D(plotObject, ax, fine, cmap, norm, foc1, foc2)

        if ret:
            return fig, ax
        
        elif save:
            pt.savefig(fname=self.savePath + '{}.jpg'.format(plotObject["name"]),bbox_inches='tight', dpi=300)
            pt.close()

        elif show:
            pt.show()

    ##
    # Plot the current system. Plots the reflectors and optionally ray-trace frames in a 3D plot.
    #
    # The ray-trace frames to plot are supplied as a list to the "RTframes" parameter.
    # Note that matplotlib offers custom control over figures in the matplotlib window.
    # This means that most parameters described for this method can be adjusted in the matplotlib plotting window.
    #
    # @ingroup public_api_vis
    #
    # @param name_surface Name of reflector to plot.
    # @param cmap Colormap of reflector. Default is cool.
    # @param norm Plot reflector normals. Default is False.
    # @param fine Spacing of normals for plotting. Default is 2.
    # @param show Show plot. Default is True.
    # @param foc1 Plot focus 1. Default is False.
    # @param foc2 Plot focus 2. Default is False.
    # @param save Save the plot.
    # @param ret Return Figure and Axis. Only used in GUI.
    # @param select A list of names of reflectors to plot. If not given, plot all reflectors.
    # @param RTframes A list of names of frame to plot. If not given, plot no ray-trace frames.
    def plotSystem(self, cmap=cm.cool,
                norm=False, fine=2, show=True, foc1=False, foc2=False, save=False, ret=False, select=None, RTframes=None, RTcolor="black"):

        select = [] if select is None else select
        RTframes = [] if RTframes is None else RTframes
        
        plotDict = {}
        if select:
            for name in select:
                check_elemSystem(name, self.system, self.clog, extern=True)
                plotDict[name] = self.system[name]
        else:
            plotDict = self.system
        
        _RTframes = []
        if RTframes:
            for name in RTframes:
                check_frameSystem(name, self.frames, self.clog, extern=True)
                _RTframes.append(self.frames[name])


        fig, ax = pt.subplots(figsize=(10,10), subplot_kw={"projection": "3d"})
        plt.plotSystem(plotDict, ax, fine, cmap,norm,
                    foc1, foc2, _RTframes, RTcolor)

        if ret:
            return fig, ax
        
        elif save:
            pt.savefig(fname=self.savePath + 'system.pdf',bbox_inches='tight', dpi=300)
            pt.close()

        elif show:
            pt.show()
    
    ##
    # Plot a group of reflectors.
    #
    # Note that matplotlib offers custom control over figures in the matplotlib window.
    # This means that most parameters described for this method can be adjusted in the matplotlib plotting window.
    #
    # @ingroup public_api_vis
    #
    # @param name_group Name of group to be plotted.
    # @param show Show the plot.
    # @param ret Whether to return figure and axis.
    def plotGroup(self, name_group, show=True, ret=False):
        select = [x for x in self.groups[name_group]["members"]]

        if ret:
            fig, ax = self.plotSystem(select=select, show=False, ret=True)
            return fig,ax
        else:
            self.plotSystem(select=select, show=show)

    ##
    # Create a spot diagram of a ray-trace frame.
    #
    # Note that matplotlib offers custom control over figures in the matplotlib window.
    # This means that most parameters described for this method can be adjusted in the matplotlib plotting window.
    #
    # @ingroup public_api_vis
    #
    # @param name_frame Name of frame to plot.
    # @param project Set abscissa and ordinate of plot. Should be given as a string. Default is "xy".
    # @param ret Return Figure and Axis. Default is False.
    # @param aspect Aspect ratio of plot. Default is 1.
    # @param unit Units of the axes for the plot.
    def plotRTframe(self, name_frame, project="xy", ret=False, aspect=1, unit="mm"):
        unit = self._units(unit)
        check_frameSystem(name_frame, self.frames, self.clog, extern=True)
        if ret:
            return plt.plotRTframe(self.frames[name_frame], project, self.savePath, ret, aspect, unit)
        else:
            plt.plotRTframe(self.frames[name_frame], project, self.savePath, ret, aspect, unit)


    ##
    # Find the focus of a ray-trace frame.
    #
    # Adds a new plane to the System, perpendicular to the mean ray-trace tilt of the input frame.
    # The new plane is called focal_plane_<name_frame> and stored in the internal system dictionary.
    # After completion, the new plane is centered at the ray-trace focus.
    # The focus frame is stored as focus_<name_frame> in the internal frames dictionary.
    #
    # @ingroup public_api_frames
    #
    # @param name_frame Name of the input frame.
    # @param f0 Initial try for focal distance.
    # @param verbose Allow verbose System logging.
    #
    # @returns out The focus co-ordinate.
    def findRTfocus(self, name_frame, f0=None, tol=1e-12):
        check_frameSystem(name_frame, self.frames, self.clog, extern=True)
        f0 = 0 if f0 is None else f0
       
        
        tilt = self.calcRTtilt(name_frame)
        center = self.calcRTcenter(name_frame)
        match = self.copyObj(world.IAX())
        
        if np.all(np.isclose(match, -tilt)):
            R = np.eye(4)
        else:
            R = self.findRotation(match, tilt)
        
        t_name = f"focal_plane_{name_frame}"
        fr_out = f"focus_{name_frame}"

        target = {
                "name"      : t_name,
                "gmode"     : "xy",
                "lims_x"    : np.array([-4.2, 4.2]),
                "lims_y"    : np.array([-4.2, 4.2]),
                "gridsize"  : np.array([3, 3])
                }

        self.addPlane(target)
        self.system[t_name]["transf"] = R 
        self.translateGrids(t_name, center)
        
        runRTDict = {
                "fr_in"     : name_frame,
                "fr_out"    : fr_out,
                "t_name"    : t_name,
                "device"    : "CPU",
                "tol"       : tol,
                "nThreads"  : 1
                }

        self.clog.work(f"Finding focus of {name_frame}...")
        
        verbosity_init = self.verbosity
        self.setLoggingVerbosity(verbose=False)
        
        res = fmin(self._optimiseFocus, f0, args=(runRTDict, tilt), full_output=True, disp=False, ftol=tol)
 
        out = res[0] * tilt + center
        self.translateGrids(t_name, out, mode="absolute")
        
        self.setLoggingVerbosity(verbose=verbosity_init)
        self.clog.result(f"Focus of frame {name_frame}: {*['{:0.3e}'.format(x) for x in out],}, RMS: {res[1]:.3e}")

        return out
        
    ##
    # Create a deep copy of any object.
    # 
    # @param obj Object do be deepcopied.
    #
    # @returns copy A deepcopy of obj.
    def copyObj(self, obj=None):
        obj = self if obj is None else obj
        return copy.deepcopy(obj)

    ##
    # Find rotation matrix to rotate v onto u.
    #
    # @param v Numpy array of length 3. 
    # @param u Numpy array of length 3.
    def findRotation(self, v, u):
        I = np.eye(3)
        if np.array_equal(v, u):
            return self.copyObj(world.INITM())

        lenv = np.linalg.norm(v)
        lenu = np.linalg.norm(u)

        if lenv == 0 or lenu == 0:
            self.clog.error("Encountered 0-length vector. Cannot proceed.")
            return None

        w = np.cross(v/lenv, u/lenu)

        lenw = np.linalg.norm(w)
        
        K = np.array([[0, -w[2], w[1]], [w[2], 0, -w[0]], [-w[1], w[0], 0]])

        R = I + K + K @ K * (1 - np.dot(v, u)) / lenw**2

        R_transf = self.copyObj(world.INITM())
        R_transf[:-1, :-1] = R
        
        return R_transf
    
    ##
    # Find x, y and z rotation angles from general rotation matrix.
    # Note that the angles are not necessarily the same as the original angles of the matrix.
    # However, the matrix constructed by the found angles applies the same 3D rotation as the input matrix.
    #
    # @param M Numpy array of shape (3,3) containg a general rotation matrix.
    #
    # @returns r Numpy array of length 3 containing rotation angles around x, y and z.
    def getAnglesFromMatrix(self, M):
        if M[2,0] < 1:
            if M[2,0] > -1:
                ry = np.arcsin(-M[2,0])
                rz = np.arctan2(M[1,0], M[0,0])
                rx = np.arctan2(M[2,1], M[2,2])

            else:
                ry = np.pi / 2
                rz = -np.arctan2(-M[1,2], M[1,1])
                rx = 0

        else:
            ry = -np.pi / 2
            rz = np.arctan2(-M[1,2], M[1,1])
            rx = 0

        r = np.degrees(np.array([rx, ry, rz]))

        return r#, testM
    
    ##
    # Calculate gridsize for which problem converges.
    #
    # This function calculates the gridsize for a target surface in order to obtain a convergent solution.
    # First, a small patch is selected from the middle of the target surface and given a starting gridsize.
    # The brightest component of the source distribution is then selected and copied into a PO scalarfield object.
    # The scalarfield is propagated to the target patch and the total incident power is calculated.
    # Then, the propagation is performed again but now the gridsize of the patch is smaller.
    # The power is calculated again and compared with the previous result.
    # If this result is smaller than the given tolerance, the new gridsize is accepted as the converged gridsize.
    # If not, another iteration is started.
    # If the maximal number of iterations is exceeded, `PyPO` will throw an error and stop.
    #
    # @ingroup public_api_po
    #
    # @param source_field Name of field to use for auto convergence. Should be the field that is to be propagated.
    # @param name_target Name of target surface.
    # @param tol Tolerance for specifying when convergence has been reached.
    # @param add Increment in gridsize for each iteration.
    # @param patch_size Factor for reducing size of target in order to save time. Should be smaller than 1.
    # @param max_iter Maximum number of iterations before auto convergence errors.
    #
    # @param returns gridsize Gridsize, scaled to full target, for which solution converged.
    def autoConverge(self, source_field, name_target, tol=1e-2, add=10, patch_size=1/9, max_iter=1000):
        self.clog.work(f"*** Starting auto-convergence *** ")
        logstate = self.verbosity
        self.setLoggingVerbosity(False)
        gridsize = np.array([1,1])
        diff = 1e99

        P0 = 1e99

        max_E = []
        for i in range(6):
            max_E.append(np.max(np.absolute(self.fields[source_field][i])))

        comp = self.fields[source_field][np.argmax(np.array(max_E))]
  
        self.scalarfields[f"_{source_field}"] = scalarfield(comp)
        self.scalarfields[f"_{source_field}"].setMeta(self.fields[source_field].surf, self.fields[source_field].k)

        if self.system[name_target]["gmode"] == 1:
            xu = "lims_u"
            yv = "lims_v"
        
        elif self.system[name_target]["gmode"] == 0:
            xu = "lims_x"
            yv = "lims_y"
        
        self.system[name_target][xu] = patch_size * self.system[name_target][xu]
        self.system[name_target][yv] = patch_size * self.system[name_target][yv]
        
        runPODict = {
                "t_name"    : name_target,
                "s_scalarfield" : f"_{source_field}",
                "epsilon"   : 10,
                "exp"       : "fwd",
                "mode"      : "scalar",
                "name_field"   : "_S_conv"
                }

        n = 0
        norm = 1
        while np.absolute(diff) > tol:
            gridsize += add
            self.system[name_target]["gridsize"] = gridsize
            self.runPO(runPODict)
            
            if n == 0:
                norm = np.max(np.absolute(self.scalarfields["_S_conv"].S))            
            
            _grid = self.generateGrids(name_target)
            P = np.sum(np.absolute(self.scalarfields["_S_conv"].S / norm)**2 * _grid.area)
            diff = np.absolute(P0 - P)
            P0 = P
            self.removeScalarField("_S_conv")
            
            self.setLoggingVerbosity(True)
            self.clog.work(f"Difference : {diff} at gridsize {*['{:0.3e}'.format(x) for x in list(gridsize)],}")
            self.setLoggingVerbosity(False)
            
            n += 1
            if n >= max_iter:
                self.setLoggingVerbosity(logstate)
                self.clog.error("Could not find converging solution.")
                self.system[name_target][xu] /= patch_size
                self.system[name_target][yv] /= patch_size
                self.system[name_target]["gridsize"] = (self.system[name_target]["gridsize"] / patch).astype(int)
                return gridsize

        self.setLoggingVerbosity(logstate)
        self.system[name_target][xu] /= patch_size
        self.system[name_target][yv] /= patch_size
        
        gridsize = (gridsize / patch_size).astype(int)
        
        self.system[name_target]["gridsize"] = gridsize
        
        self.clog.result(f"Found converged solution, gridsize: {*['{:0.3e}'.format(x) for x in list(gridsize)],}")
        return gridsize
    
    #############################################################
    #                                                           #
    #                         GUI METHODS                       #
    #                                                           #
    #############################################################
    
    ##
    # Instantiate a GUI PO propagation. Stores desired output in the system.fields and/or system.currents lists.
    # If the 'EHP' mode is selected, the reflected Poynting frame is stored in system.frames.
    #
    # @param PODict Dictionary containing the PO propagation instructions.
    #
    # @see PODict
    def runGUIPO(self, runPODict):
        _runPODict = self.copyObj(runPODict)

        if _runPODict["mode"] != "scalar":
            sc_name = _runPODict["s_current"]
            _runPODict["s_current"] = self.currents[_runPODict["s_current"]]
            source = self.system[_runPODict["s_current"].surf]
            _runPODict["k"] = _runPODict["s_current"].k

        else:
            sc_name = _runPODict["s_scalarfield"]
            _runPODict["s_scalarfield"] = self.scalarfields[_runPODict["s_scalarfield"]]
            source = self.system[_runPODict["s_scalarfield"].surf]
            _runPODict["k"] = _runPODict["s_scalarfield"].k
       
        target = self.system[_runPODict["t_name"]]
        
        if _runPODict["device"] == "CPU":
            out = PyPO_CPUd(source, target, _runPODict)

        elif _runPODict["device"] == "GPU":
            out = PyPO_GPUf(source, target, _runPODict)
        
        if _runPODict["mode"] == "JM":
            out.setMeta(_runPODict["t_name"], _runPODict["k"])
            self.currents[_runPODict["name_JM"]] = out
        
        elif _runPODict["mode"] == "EH" or _runPODict["mode"] == "FF":
            out.setMeta(_runPODict["t_name"], _runPODict["k"])
            self.fields[_runPODict["name_EH"]] = out
        
        elif _runPODict["mode"] == "JMEH":
            out[0].setMeta(_runPODict["t_name"], _runPODict["k"])
            out[1].setMeta(_runPODict["t_name"], _runPODict["k"])
            self.currents[_runPODict["name_JM"]] = out[0]
            self.fields[_runPODict["name_EH"]] = out[1]
        
        elif _runPODict["mode"] == "EHP":
            out[0].setMeta(_runPODict["t_name"], _runPODict["k"])
            self.fields[_runPODict["name_EH"]] = out[0]

            frame = self._loadFramePoynt(out[1], _runPODict["t_name"])
            self.frames[_runPODict["name_P"]] = frame
            self.assoc[_runPODict["t_name"]] = [_runPODict["name_EH"], _runPODict["name_P"]]

        elif _runPODict["mode"] == "scalar":
            out.setMeta(_runPODict["t_name"], _runPODict["k"])
            self.scalarfields[_runPODict["name_field"]] = out

        return out
    
    ##
    # Run a ray-trace propagation from a frame to a surface in the GUI.
    #
    # @param runRTDict A runRTDict object specifying the ray-trace.
    def runGUIRayTracer(self, runRTDict):
        _runRTDict = self.copyObj(runRTDict)

        _runRTDict["fr_in"] = self.frames[_runRTDict["fr_in"]]
        _runRTDict["t_name"] = self.system[_runRTDict["t_name"]]
       
        if _runRTDict["device"] == "CPU":
            frameObj = RT_CPUd(_runRTDict)

        elif _runRTDict["device"] == "GPU":
            frameObj = RT_GPUf(_runRTDict)
        
        self.frames[runRTDict["fr_out"]] = frameObj
        self.frames[runRTDict["fr_out"]].setMeta(self.calcRTcenter(runRTDict["fr_out"]), self.calcRTtilt(runRTDict["fr_out"]), self.copyObj(world.INITM()))
    
    ##
    # Perform a hybrid RT/PO GUI propagation, starting from a reflected field and set of Poynting vectors.
    #
    # @param hybridDict A hybridDict dictionary.
    def hybridGUIPropagation(self, hybridDict):
        field = self.copyObj(self.fields[hybridDict["field_in"]])

        runRTDict = {
                "fr_in"     : hybridDict["fr_in"],
                "t_name"    : hybridDict["t_name"],
                "fr_out"    : hybridDict["fr_out"],
                "device"    : "CPU"
                }

        self.runGUIRayTracer(runRTDict)

        stack = self.calcRayLen(hybridDict["fr_in"], hybridDict["fr_out"], start=hybridDict["start"])
        if hybridDict["start"] is not None:
            expo = np.exp(1j * field.k * stack[1]) * np.sqrt(stack[0] / (2*stack[1] + stack[0])) # Initial curvature

        else:
            expo = np.exp(1j * field.k * stack[0])

        _comps = []
        for i in range(6):
            _comps.append((expo * field[i].ravel()).reshape(field[i].shape))

        field_prop = fields(*_comps)
        field_prop.setMeta(hybridDict["t_name"], field.k)

        self.fields[hybridDict["field_out"]] = field_prop

        if interp:
            self.interpFrame(hybridDict["fr_out"], hybridDict["field_out"], hybridDict["t_name"], hybridDict["field_out"], comp=hybridDict["comp"])
    #############################################################
    #                                                           #
    #                       PRIVATE METHODS                     #
    #                                                           #
    #############################################################
    
    ##
    # Convert a Poynting vector grid to a frame object.
    # 
    # @param Poynting An rfield object containing reflected Poynting vectors.
    # @param name_source Name of reflector on which reflected Poynting vectors are defined
    #
    # @returns frame_in Frame object containing the Poynting vectors and base points.
    #
    # @see rfield
    # @see frame
    def _loadFramePoynt(self, Poynting, name_source):
        check_elemSystem(name_source, self.system, self.clog, extern=True)
        grids = generateGrid(self.system[name_source])

        nTot = Poynting.x.shape[0] * Poynting.x.shape[1]
        frame_in = frame(nTot, grids.x.ravel(), grids.y.ravel(), grids.z.ravel(),
                        Poynting.x.ravel(), Poynting.y.ravel(), Poynting.z.ravel())

        return frame_in
    
    ##
    # Cost function for finding a ray-trace frame focus.
    # Optimises RMS spot size as function of tilt multiple f0.
    #
    # @param f0 Tilt multiple for finding focus.
    # @param args The runRTDict for propagation and ray-trace tilt of input frame.
    #
    # @returns RMS The RMS spot size of the frame at f0 times the tilt.
    def _optimiseFocus(self, f0, *args):
        runRTDict, tilt = args

        trans = f0 * tilt

        self.translateGrids(f"focal_plane_{runRTDict['fr_in']}", trans)
        
        self.runRayTracer(runRTDict)
        #self.plotSystem(RTframes=["start", "pri", f"focus_{runRTDict['fr_in']}"])
        RMS = self.calcSpotRMS(f"focus_{runRTDict['fr_in']}")
        self.translateGrids(f"focal_plane_{runRTDict['fr_in']}", -trans)
        #self.removeFrame() 
        return RMS
    
    ##
    # Check if an element to be rotated is bound to a PO field/current.
    # If so, rotate vectorial field/current components along.
    #
    # @param name Name of reflector to be rotated.
    # @param transf Array containing the transformation of the reflector.
    def _checkBoundPO(self, name, transf):

        bound_fields = []
        bound_currents = []

        for key, item in self.fields.items():
            if hasattr(item, "surf"):
                if item.surf == name:
                    bound_fields.append(key)
        
        for key, item in self.currents.items():
            if hasattr(item, "surf"):
                if item.surf == name:
                    bound_currents.append(key)

        if bound_fields:
            for field in bound_fields:
                out = transformPO(self.fields[field], transf)
                self.fields[field] = self.copyObj(out)

        if bound_currents:
            for current in bound_currents:
                out = transformPO(self.currents[current], transf)
                self.currents[current] = self.copyObj(out)
   
    ##
    # Transform a single component to a filled fields object by setting all other components to zero.
    #
    # @param comp Name of component.
    # @param field Array to be inserted in fields object.
    #
    # @returns field_c Filled fields object with one component filled.
    def _compToFields(self, comp, field):
        null = np.zeros(field.shape, dtype=complex)

        if comp == "Ex":
            field_c = fields(field, null, null, null, null, null)
        elif comp == "Ey":
            field_c = fields(null, field, null, null, null, null)
        elif comp == "Ez":
            field_c = fields(null, null, field, null, null, null)
        elif comp == "Hx":
            field_c = fields(null, null, null, field, null, null)
        elif comp == "Hy":
            field_c = fields(null, null, null, null, field, null)
        elif comp == "Hz":
            field_c = fields(null, null, null, null, null, field)

        return field_c

    ##
    # Convert a string representation of a unit to a list containing the unit and conversion factor.
    # The conversion is done with respect of the standard PyPO units, which are millimeters.
    # This method is only used for plotting.
    #
    # @param unit String representation of the unit.
    # @param default Default unit, millimeters.
    #
    # @returns out List containing the string unit and the corresponding conversion factor.
    def _units(self, unit, default="mm"):
        if unit == "m":
            return [unit, 1e-3]

        elif unit == "mm":
            return [unit, 1.]

        elif unit == "cm":
            return [unit, 1e-2]
        
        elif unit == "um":
            return [unit, 1e3]
        
        elif unit == "nm":
            return [unit, 1e6]

        elif unit == "deg":
            return [unit, 1.]

        elif unit == "am":
            return [unit, 60]

        elif unit == "as":
            return [unit, 3600]

        else:
            return [default, 1.]



















