# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/00_core.ipynb.

# %% auto 0
__all__ = ['Var', 'Const', 'Func', 'Goal', 'Expression', 'variable', 'constant', 'equation', 'equals', 'not_equals',
           'make_examples', 'prove', 'contradiction_proof']

# %% ../nbs/00_core.ipynb 3
from typing import Callable, List, Tuple, Union
from sympy import Equality, Unequality
from sympy.core.relational import Relational
from sympy.core.basic import Basic
from random import randint, seed
import sympy as sp

from IPython.display import display, Latex

import typing
import inspect

# %% ../nbs/00_core.ipynb 4
# Basic types
Var = sp.Symbol
Const = sp.Number
Func = Callable[[Var], sp.Expr]
Goal = Union[Equality, Unequality, Relational]
Expression = Union[sp.Expr, Basic]

# TODO - build in a repr override to use latex

# Helper functions to create a more user-friendly interface
def variable(name: str) -> Var:
    return sp.Symbol(name)

def constant(value: Union[int, float]) -> Const:
    return sp.Number(value)

def equation(expr: str) -> sp.Expr:
    return sp.sympify(expr, evaluate=False)

def equals(lhs: sp.Expr, rhs: sp.Expr) -> Equality:
    return sp.Eq(lhs, rhs, evaluate=False)

def not_equals(lhs: Expression, rhs: Expression) -> Unequality:
    return sp.Ne(lhs, rhs, evaluate=False)

# %% ../nbs/00_core.ipynb 5
def make_examples(domain: str, N: int, equation: str) -> List[Tuple[sp.Expr, sp.Expr]]:
    """For a given domain and equation, select N examples and generate a list of N input-output pairs.
    Currently, the domain can be either 'real' or 'integer', and one variable is assumed."""
    examples = []
    if domain == 'real':
        # select N random real numbers
        for _ in range(N):
            x = sp.Symbol('x')
            x_val = randint(-100, 100)
            y_val = sp.sympify(equation).subs(x, x_val)
            examples.append((x_val, y_val))
    elif domain == 'integer':
        # select N random integers
        for _ in range(N):
            x = sp.Symbol('x', integer=True)
            x_val = randint(-100, 100)
            y_val = sp.sympify(equation).subs(x, x_val)
            examples.append((x_val, y_val))
    return examples

# %% ../nbs/00_core.ipynb 7
def prove(goal: Goal, proof_func: Callable[..., Goal], *args) -> bool:
    try:
        derived_goal = proof_func(*args)
        if goal == derived_goal:
            display(Latex(f"$$\\text \\quad {sp.latex(goal)} \\quad Q.E.D.$$"))
            return True
    except Exception as e:
        print(f"Proof error: {str(e)}")
        print("Check your assumptions and proof function for errors.")
        return False

# %% ../nbs/00_core.ipynb 8
def contradiction_proof(proof):
    def wrapper(*args, **kwargs):
        hints = typing.get_type_hints(proof)
        if hints != {}:
            if hints.get('return') != Unequality:
                print(hints.get('return'))
                raise TypeError("Proof function must return Unequality")
        else:
            try:
                # add all of the arguments to the local namespace with their existing names that are passed in.
                args_list = lambda args: [_arg for _arg in args]
                _printed = ['_i', '_arg', 'line', 'var_name','args_list', '_printed', 'var_value', 'proof', 'args', 'kwargs', 'hints']
                for _i, _arg in enumerate(args_list(args)):
                    exec(f"{_arg} = args[{_i}]", globals(), locals())
                    _printed.append(str(_arg))
                for _i, line in enumerate(inspect.getsourcelines(proof)[0]):
                    #print each varaible only once, and add opt outs
                    line = line.strip()
                    if line.startswith('#'):
                        # in future concatenate all the strings into one doc and format nicely.
                        # first attempt didn't work out, had weird formatting issues.
                        display(Latex(f"{line[1:].strip()}"))
                        continue
                    if line.startswith('def'):
                        continue
                    if line.startswith('@'):
                        continue
                    if line.startswith('return'):
                        line = line[7:]
                    if line == '':
                        continue
                    exec(line, globals(), locals())
                    # print(f"\nProof state after line {i+1}: {line}")
                    for var_name, var_value in locals().items():
                        if var_name in _printed:
                            continue
                        else:
                            _printed.append(var_name)
                        # if isinstance(var_value, (Var, Const, Func)):
                        display(Latex(f"$${sp.latex(var_value)}$$"))
            except Exception as e:
                print(f"Error in proof function: {str(e)}")
                raise
            # there might be something weird around result that would prevent it from being printed if it's in the proof. check that later
            result = proof(*args, **kwargs)
            if not isinstance(result, Unequality):
                raise TypeError("Proof function must return Unequality")
            return result
    return wrapper
