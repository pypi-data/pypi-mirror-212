#!/usr/bin/env python3

# ------------------------------------------------------------------------------
# InternetSpeedVisualizer
#
# InternetSpeedVisualizer is a powerful tool designed to help you visualize and
# analyze your Internet speed data, collected using the InternetSpeedLogger.
#
# https://github.com/Andreas-Menzel/InternetSpeedVisualizer/
# https://pypi.org/project/InternetSpeedVisualizer/
# ------------------------------------------------------------------------------
# @author: Andreas Menzel
# @license: MIT License
# ------------------------------------------------------------------------------

import argparse
from datetime import datetime
import matplotlib.dates as mdates
import matplotlib.pyplot as plt
import pandas as pd
from pathlib import Path
from tempfile import gettempdir


script_version = '1.1.0'


def argparse_check_positive(value):
    ivalue = int(value)
    if ivalue <= 0:
        raise argparse.ArgumentTypeError(
            "%s is an invalid positive int value" % value)
    return ivalue


def argparse_check_pair_positive(value):
    value_a = 0
    value_b = 0

    value_split = value.split(';')
    if len(value_split) == 2:
        value_a = value_split[0]
        value_b = value_split[1]
    else:
        raise argparse.ArgumentTypeError(
            "%s is an invalid positive int pair value" % value)

    if value_a != '' and int(value_a) <= 0:
        raise argparse.ArgumentTypeError(
            "%s is an invalid positive int value" % value)
    if value_b != '' and int(value_b) <= 0:
        raise argparse.ArgumentTypeError(
            "%s is an invalid positive int value" % value)

    return f'{value_a};{value_b}'


def setupArgumentParser():
    parser = argparse.ArgumentParser(
        prog='InternetSpeedVisualizer',
        description="""
InternetSpeedVisualizer is a powerful tool designed to help you visualize and
analyze your Internet speed data, collected using the InternetSpeedVisualizer.
            """,
        epilog="""
Passing only minimum download speed:
    --download \"200;\"
Passing only maximum download speed:
    --download \";250\"
Passing only minimum upload speed:
    --upload \"30;\"
Passing only maximum upload speed:
    --upload \";40\"
        """,
        formatter_class=argparse.RawDescriptionHelpFormatter)
    parser.add_argument('--version', action='version',
                        version='%(prog)s ' + script_version)
    parser.add_argument('-i', '--input',
                        help='Path to the .csv-log-file generated by InternetSpeedVisualizer.',
                        required=True)
    parser.add_argument('-o', '--output',
                        help='Path to the line-graph-image that should be created.',
                        default='')
    parser.add_argument('--width',
                        help='Width in inch of the output image. (default: %(default)s)',
                        type=argparse_check_positive,
                        default=20)
    parser.add_argument('--height',
                        help='Height in inch of the output image. (default: %(default)s)',
                        type=argparse_check_positive,
                        default=10)
    parser.add_argument('-d', '--download',
                        metavar='<min>;<max>',
                        help='Download speed promised by the ISP. (default: "%(default)s")',
                        type=argparse_check_pair_positive,
                        default='180;250')
    parser.add_argument('-u', '--upload',
                        metavar='<min>;<max>',
                        help='Upload speed promised by the ISP. (default: "%(default)s")',
                        type=argparse_check_pair_positive,
                        default='35;40')
    parser.add_argument('--interactive',
                        help='Show an interactive line-graph. (default: %(default)s)',
                        action='store_true')
    parser.add_argument('-no', '--no_overwrite',
                        help='Set this flag to automatically select a similar output-filename, so a potentially already existing file will not be overwritten.',
                        action='store_true')
    return parser.parse_args()


def main():
    args = setupArgumentParser()

    download_min = 0
    download_max = 0
    if args.download.split(';')[0] != '':
        download_min = int(args.download.split(';')[0])
    if args.download.split(';')[1] != '':
        download_max = int(args.download.split(';')[1])

    upload_min = 0
    upload_max = 0
    if args.upload.split(';')[0] != '':
        upload_min = int(args.upload.split(';')[0])
    if args.upload.split(';')[1] != '':
        upload_max = int(args.upload.split(';')[1])

    if not Path(args.input).exists():
        raise FileNotFoundError(
            f'The file "{Path(args.input).absolute()}" does not exist.')

    datetimeString = datetime.now().strftime("%Y-%m-%d_%H:%M:%S")
    if args.output != '':
        if len(args.output) > 4 and args.output[-4:] == '.png':
            output_file = Path(f'{args.output}')
        else:
            output_file = Path(f'{args.output}.png')
    else:
        # Set to default/fallback location.
        output_file = Path(
            f'{Path(gettempdir(), "InternetSpeedVisualizer", datetimeString)}_internet_speeds.png')

    # Make sure that the output-file is unique and does not exist yet.
    if args.no_overwrite or args.output == '':
        if output_file.exists():
            output_file = Path(
                output_file.parent, f'{output_file.stem}_{datetimeString}{output_file.suffix}')
        if output_file.exists():
            counter = 2
            new_output_file = output_file
            while new_output_file.exists():
                new_output_file = Path(
                    csv_file.parent, f'{csv_file.stem}_{counter}{csv_file.suffix}')
                counter = counter + 1
            output_file = new_output_file

    print(f"""\
InternetSpeedVisualizer (version {script_version})

Output-file: "{output_file.absolute()}"\
    """)

    # Read the CSV file and prepare values
    data = pd.read_csv(args.input)
    data = data[['Datetime', 'Download (Mbps)', 'Upload (Mbps)']]
    data['Datetime'] = pd.to_datetime(data['Datetime'])

    # Plot the line graph
    fig, ax = plt.subplots()
    ax.plot(data['Datetime'], data['Download (Mbps)'], label='Download')
    ax.plot(data['Datetime'], data['Upload (Mbps)'], label='Upload')

    # Customize the graph
    plt.xlabel('Date & Time')
    plt.ylabel('Speed (Mbps)')
    plt.title('Download and Upload Speed')
    plt.legend()

    ax.xaxis.set_major_formatter(mdates.DateFormatter("%Y-%m-%d %H:%M"))
    ax.xaxis.set_minor_formatter(mdates.DateFormatter("%Y-%m-%d %H:%M"))

    # Add vertical lines everyday at midnight
    first_midnight = data['Datetime'].min()
    if (first_midnight - first_midnight.replace(hour=0, minute=0, second=0, microsecond=0)).total_seconds() != 0:
        first_midnight = (first_midnight + pd.Timedelta(days=1)
                          ).replace(hour=0, minute=0, second=0, microsecond=0)

    midnight_range = pd.date_range(
        start=first_midnight, end=data['Datetime'].max(), freq='24H')
    for midnight in midnight_range:
        plt.axvline(midnight, color='gray', linestyle='-', linewidth=1)

    # Add horizontal lines at download_min, download_max, upload_min and upload_max
    if download_max > 0:
        plt.axhline(download_max, color='green', linestyle='-', linewidth=3)
    if download_min > 0:
        plt.axhline(download_min, color='red', linestyle='-', linewidth=2)
    if upload_max > 0:
        plt.axhline(upload_max, color='green', linestyle='-', linewidth=2)
    if upload_min > 0:
        plt.axhline(upload_min, color='red', linestyle='-', linewidth=1)

    # Add horizontal lines every 50 (Mbps)
    max_recorded_download = max(data['Download (Mbps)'])
    max_recorded_upload = max(data['Upload (Mbps)'])
    max_speed_in_graph = max(max_recorded_download, max_recorded_upload, download_max, upload_max)
    y_ticks = [y for y in range(0, max_speed_in_graph, 50) if y != download_min
               and y != download_max and y != upload_min and y != upload_max]
    for y in y_ticks:
        plt.axhline(y, color='gray', linestyle='dotted', linewidth=0.5)

    # Save the graph as an image
    output_file.parent.mkdir(parents=True, exist_ok=True)
    fig.set_size_inches(args.width, args.height)
    plt.savefig(output_file)

    # Show the graph
    if args.interactive:
        plt.show()


if __name__ == '__main__':
    main()
