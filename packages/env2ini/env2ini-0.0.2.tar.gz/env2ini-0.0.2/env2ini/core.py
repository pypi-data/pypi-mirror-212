# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/00_core.ipynb.

# %% auto 0
__all__ = ['NBKS_DIR', 'ROOT_DIR', 'EXPL_DIR', 'DATA_DIR', 'RESULTS_DIR', 'FIGURES_DIR', 'PIP', 'DEP_SEP', 'CONDA_NAME',
           'PYPI_NAME', 'DEFAULT_DEPENDENCIES_TO_IGNORE', 'SETTINGS_INI', 'ENV_DEPENDENCIES', 'INI_REQUIREMENTS',
           'YamlDependencyStr', 'IniRequirementStr', 'YamlFileItem', 'YamlDependencies', 'Dependencies',
           'CondaDependencies', 'IniRequirements', 'console', 'app', 'is_valid_conda_package_name_char',
           'split_package_str_at_first_non_alpha', 'find_added_packages', 'find_removed_packages',
           'find_changed_packages', 'find_unchanged_packages', 'compare_requirements', 'read_ini_file',
           'to_macos_env_file', 'Dependency', 'CondaDependency', 'IniRequirement', 'DependencyList', 'cprint',
           'print_changes', 'convert', 'run']

# %% ../nbs/00_core.ipynb 3
import os

import typer
import yaml
import configparser

from rich.table import Table
from rich.console import Console
from rich.repr import auto as rich_auto
from dataclasses import dataclass, field

from typing import (
    List, Final, Tuple, Union,
    TypeAlias, Sequence,  Optional, 
    ClassVar,
)

# %% ../nbs/00_core.ipynb 5
'''----------------------------------------------------
NOTE: RELATIVE DEFINITIONS
----------------------------------------------------'''

# nbdev nbs directory, i.e. `nbs/``
NBKS_DIR = os.path.abspath('')

# project root directory
ROOT_DIR = os.path.join(NBKS_DIR, '..')

# where example notebooks are stored, i.e. `examples/`
EXPL_DIR = os.path.join(ROOT_DIR, 'examples')

# where small data is stored, i.e. `data/`
DATA_DIR = os.path.join(ROOT_DIR, 'data')

# where small data is stored, i.e. `results/`
RESULTS_DIR = os.path.join(ROOT_DIR, 'results')

# where small data is stored, i.e. `figures/`
FIGURES_DIR = os.path.join(ROOT_DIR, 'figures')

# %% ../nbs/00_core.ipynb 7
PIP = 'pip'

DEP_SEP = '::'

CONDA_NAME = 'conda_name'

PYPI_NAME = 'pypi_name'

DEFAULT_DEPENDENCIES_TO_IGNORE = ['python', 'pip']

SETTINGS_INI = 'settings.ini'

ENV_DEPENDENCIES = 'dependencies'
INI_REQUIREMENTS = 'requirements'

# %% ../nbs/00_core.ipynb 9
# NOTE: this is a type alias for a string that represents a dependency _line_ 
#       from the `env.yml` file.
YamlDependencyStr: TypeAlias = str

IniRequirementStr: TypeAlias = str

YamlFileItem: TypeAlias = Union[YamlDependencyStr, dict]

YamlDependencies: TypeAlias = Sequence[YamlDependencyStr]

Dependencies: TypeAlias = Sequence['Dependency']

CondaDependencies: TypeAlias = Sequence['CondaDependency']

IniRequirements: TypeAlias = Sequence['IniRequirement']

# %% ../nbs/00_core.ipynb 11
def is_valid_conda_package_name_char(char: str) -> bool:
    '''
    Used to split a package name from a version number.
    This is achieved by checking if a character is valid for 
    a conda package name. Since between the package name and
    the version number there is a space, or conditional (`>`, `<`, `=`, etc).    
    '''
    return char.isalnum() or char in ['-', '_', '.']

def split_package_str_at_first_non_alpha(package_str: str) -> Tuple[str, str]:
    idx = next((
        i for i, char in enumerate(package_str) 
        if is_valid_conda_package_name_char(char)
    ), len(package_str))
    return package_str[:idx], package_str[idx:]


# %% ../nbs/00_core.ipynb 12
def find_added_packages(old_packages: Dependencies,  new_packages: Dependencies) -> Dependencies:
    old_pkgs = DependencyList(old_packages)
    new_pkgs = [pkg for pkg in new_packages if pkg not in old_pkgs]
    return new_pkgs

def find_removed_packages(old_packages: Dependencies,  new_packages: Dependencies) -> Dependencies:
    new_pkgs = DependencyList(new_packages)
    old_pkgs = [pkg for pkg in old_packages if pkg not in new_pkgs]
    return old_pkgs
       
def find_changed_packages(old_packages: Dependencies,  new_packages: Dependencies) -> Dependencies:
    old_pkgs = DependencyList(old_packages)
    new_pkgs = DependencyList(new_packages)

    old_as_new = list(map(lambda pkg: new_pkgs.find(pkg), old_pkgs))

    changed = [
        (pkg, old_as_new[i]) for i, pkg in enumerate(old_pkgs)
        if old_as_new[i] and not pkg.is_same_version(old_as_new[i])
    ]
    return changed


def find_unchanged_packages(old_packages: Dependencies,  new_packages: Dependencies) -> Dependencies:
    old_pkgs = DependencyList(old_packages)
    new_pkgs = DependencyList(new_packages)
    old_as_new = list(map(lambda pkg: new_pkgs.find(pkg), old_pkgs))

    unchanged = [
        (pkg, old_as_new[i]) for i, pkg in enumerate(old_pkgs)
        if old_as_new[i] and pkg.is_same_version(old_as_new[i])
    ]
    return unchanged

def compare_requirements(old_packages: Dependencies,  new_packages: Dependencies) -> Dependencies:
    added = find_added_packages(old_packages, new_packages)
    removed = find_removed_packages(old_packages, new_packages)
    changed = find_changed_packages(old_packages, new_packages)
    remained = find_unchanged_packages(old_packages, new_packages)
    return added, removed, changed, remained

# %% ../nbs/00_core.ipynb 13
def read_ini_file(file: str = SETTINGS_INI) -> configparser.ConfigParser:    
    ini_cfg = configparser.ConfigParser()
    ini_cfg.read_file(file)    
    return ini_cfg

def to_macos_env_file(file: str) -> str:
    base_dir = os.path.dirname(file)
    yml_file = os.path.basename(file)
    mac_file = yml_file.replace('.yml', '.mac.yml')
    

    if os.path.exists(os.path.join(base_dir, mac_file)):
        return os.path.join(base_dir, mac_file)
    return file

# %% ../nbs/00_core.ipynb 16
@dataclass
@rich_auto(angular=True)
class Dependency(object):    
    package: str
    version: Optional[str] = None
    # _alias_kinds: ClassVar[List[str]] = field(default_factory=lambda: [CONDA_NAME, PYPI_NAME])
    _alias_kinds: ClassVar[List[str]] =  [CONDA_NAME, PYPI_NAME]
    
    @staticmethod
    def separate_package_from_version(package_version: str) -> Tuple[str, str]:
        package, version = split_package_str_at_first_non_alpha(package_version)
        return package, version
    
    def get_alias(self, kind:str, default:Optional[str]=None) -> str:
        alt_name = getattr(self, kind, None)
        fallback = (default or self.package)
        return alt_name or fallback

    def get_aliases(self) -> Sequence[str]:
        pkgs = [self.package]
        for kind in self._alias_kinds:
            pkgs.append(self.get_alias(kind))
        return set(pkgs)

    @property
    def aliases(self) -> str:
        try:
            return self._aliases
        except AttributeError:
            self._aliases = self.get_aliases()
            return self._aliases

    @property
    def conda_package(self) -> str:
        try:
            return self._conda_package
        except AttributeError:
            self._conda_package = self.get_alias(CONDA_NAME)
            return self._conda_package
        
    @property
    def pypi_package(self) -> str:
        try:
            return self._pypi_package
        except AttributeError:
            self._pypi_package = self.get_alias(PYPI_NAME)
            return self._pypi_package

    def is_same_package(self, other: 'Dependency') -> bool:   
        return bool(set(self.aliases) & set(other.aliases))
    
    def is_same_version(self, other: 'Dependency') -> bool:
        return self.version == other.version
    
    def __eq__(self, other):
        if isinstance(other,  (Dependency, IniRequirement, CondaDependency)):
            return self.is_same_package(other) and self.version == other.version
        return super().__eq__(other)
    
    def __contains__(self, other):
        if isinstance(other, (Dependency, IniRequirement, CondaDependency)):
            return self.is_same_package(other)
        return super().__contains__(other)
    
    def to_conda_dependency(self, channel: Optional[str]=None) -> 'CondaDependency':
        return CondaDependency(package=self.conda_package, version=self.version, channel=channel, pypi_name=self.package)
    
    def to_ini_requirement(self) -> 'IniRequirement':
        return IniRequirement(package=self.pypi_package, version=self.version, conda_name=self.package)
    

    def to_ini_str(self) -> IniRequirementStr:
        ini_req = self.to_ini_requirement()   
             
        if ini_req.version:
            return f'{ini_req.package}{ini_req.version}'
        return f'{ini_req.package}'
    
    def to_yml_str(self) -> str:
        yml_dep = self.to_conda_dependency()
        yml_str = ''

        if yml_dep.channel:
            yml_str += f'{yml_dep.channel}{DEP_SEP}'

        yml_str += f'{yml_dep.package}'

        if yml_dep.version:
            yml_str += f'{yml_dep.version}'
        return yml_str        

# %% ../nbs/00_core.ipynb 18
@dataclass
@rich_auto(angular=True)
class CondaDependency(Dependency):
    channel: Optional[str] = None
    pypi_name: Optional[str] = None

    @staticmethod
    def has_channel(dependency: YamlDependencyStr) -> bool:
        return DEP_SEP in dependency
    
    @staticmethod
    def extract_channel(dependency: YamlDependencyStr, default_channel: Optional[str] = None) -> Tuple[Optional[str], str]:
        channel = default_channel    
        if CondaDependency.has_channel(dependency):
            channel, dependency = dependency.split(DEP_SEP, 1)        
        return channel, dependency
    
    @staticmethod
    def from_yml_str(
        dependency: YamlDependencyStr, dependencies_to_ignore: Optional[List[str]] = DEFAULT_DEPENDENCIES_TO_IGNORE
    ) -> Optional['CondaDependency']:
        assert isinstance(dependency, YamlDependencyStr)
        channel, dependency = CondaDependency.extract_channel(dependency)
        package, version = CondaDependency.separate_package_from_version(dependency)

        if package in dependencies_to_ignore:
            return None
        
        return CondaDependency(package, version, channel)
    
    @staticmethod
    def from_yml_dict(
        yml_dict: dict, dependencies_to_ignore: Optional[List[str]] = DEFAULT_DEPENDENCIES_TO_IGNORE
    ) -> CondaDependencies:
        assert isinstance(yml_dict, dict)
        
        dependencies = []
        if PIP not in yml_dict:
            return dependencies
        
        pip_yml_strs = yml_dict[PIP]
        for dependency in pip_yml_strs:
            dep = CondaDependency.from_yml_str(dependency, dependencies_to_ignore)
            if dep is None:
                continue
            dependencies.append(dep)

        return dependencies
    
    @staticmethod
    def from_yml_line(
        yml_line: YamlFileItem,
        dependencies_to_ignore: Optional[List[str]] = DEFAULT_DEPENDENCIES_TO_IGNORE
    ) -> Union['CondaDependency', CondaDependencies]:
        if isinstance(yml_line, YamlDependencyStr):
            return CondaDependency.from_yml_str(yml_line, dependencies_to_ignore)
        elif isinstance(yml_line, dict):
            return CondaDependency.from_yml_dict(yml_line, dependencies_to_ignore)
        else:
            raise ValueError(f'Unexpected type: {type(yml_line)}')
        # match yml_line:
        #     case isinstance(yml_line, YamlDependencyStr):
        #         return CondaDependency.from_yml_str(yml_line, dependencies_to_ignore)
        #     case isinstance(yml_line, dict):
        #         return CondaDependency.from_yml_dict(yml_line, dependencies_to_ignore)
        #     case _:
        #         raise ValueError(f'Unexpected type: {type(yml_line)}')
            

    @staticmethod
    def load_yml_dependencies(
        yml_env_dependencies: List[YamlFileItem], 
        dependencies_to_ignore: Optional[List[str]] = DEFAULT_DEPENDENCIES_TO_IGNORE    
    ) -> CondaDependencies:
        
        dependencies = []

        for yml_item in yml_env_dependencies:
            dep = CondaDependency.from_yml_line(yml_item)
            
            if isinstance(dep, Sequence) and all(isinstance(x, CondaDependency) for x in dep):
                dependencies.extend(dep)
            # if isinstance(dep, CondaDependencies):
            #     dependencies.extend(dep)
            
            elif dep.package not in dependencies_to_ignore:
                dependencies.append(dep)
            
            else:
                continue
            
        return dependencies   
    
    @staticmethod
    def dump_ini_requirements(dependencies: CondaDependencies) -> IniRequirementStr:
        requirements = ''
        for dep in dependencies:
            requirements += dep.to_ini_str() + ' '
        return requirements


# %% ../nbs/00_core.ipynb 20
@dataclass
@rich_auto(angular=True)
class IniRequirement(Dependency):    
    conda_name: Optional[str] = None

    @staticmethod
    def from_ini_str(requirement: IniRequirementStr) -> 'IniRequirement':
        assert isinstance(requirement, IniRequirementStr)        
        package, version = IniRequirement.separate_package_from_version(requirement)
        return IniRequirement(package, version)
    
    @staticmethod
    def load_ini_requirements(
        ini_requirements_str: IniRequirementStr, 
        dependencies_to_ignore: Optional[List[str]] = DEFAULT_DEPENDENCIES_TO_IGNORE    
    ) -> IniRequirements:        
        dependencies = []
        requirements = ini_requirements_str.split()
        for req in requirements:
            dep = IniRequirement.from_ini_str(req)
            if dep.package in dependencies_to_ignore:
                continue
            dependencies.append(dep)
        return dependencies

# %% ../nbs/00_core.ipynb 22
@rich_auto(angular=True)
class DependencyList(list):
    def __contains__(self, other: Dependency) -> bool:
        return any(other in dep for dep in self)
        
    def index(self, other: Dependency) -> int:
        for i, dep in enumerate(self):
            if other in dep:
                return i
        raise ValueError(f'{other} not in {self.dependencies}')
    
    def find(self, other: Dependency) -> Optional[Dependency]:
        for dep in self:
            if other in dep:
                return dep
        return None
    
    def find_all(self, other: Dependency) -> List[Dependency]:
        results = []
        for dep in self:
            if other in dep:
                results.append(dep)
        return results

    def __getitem__(self, dependency: Dependency) -> Optional[Dependency]:
        return self.find(dependency)

# %% ../nbs/00_core.ipynb 24
console = Console()

# %% ../nbs/00_core.ipynb 25
# NOTE: utility function to print colored text
def cprint(style:str, text:str) -> None:
    console.print(f'[{style}]{text}[/{style}]')

def print_changes(added, removed, changed, remained):
    table = Table(title='Changes')
    table.add_column('Package', style='cyan')
    table.add_column('Old Version', style='magenta')
    table.add_column('New Version', style='green')
    table.add_column('Status', style='yellow')

    for dep in added:
        table.add_row(f':package: {dep.package}', '', dep.version, 'Added')
    for dep in removed:
        table.add_row(f':package: {dep.package}', dep.version, '', 'Removed')   
    for old, new in changed:
        table.add_row(f':package: {old.package}', old.version, new.version, 'Changed')
    for old, new in remained:
        table.add_row(f':package: {old.package}', old.version, new.version, 'Unchanged')
    console.print(table)
    # return table

# %% ../nbs/00_core.ipynb 27
app = typer.Typer()

# %% ../nbs/00_core.ipynb 28
@app.command()
def convert(
    file: Optional[str] = typer.Option(
        'env.yml', 
        help='YAML file to extract the new requirements from.',
    ),

    ini_file: Optional[str] = typer.Option(
        SETTINGS_INI,
        help='The settings.ini file to update.',
    ),

    macos: Optional[bool] = typer.Option(
        False,
        help='Whether or not to use the macos env file. ``',
    ),

    dryrun: Optional[bool] = typer.Option(
        True,
        help='Whether to actually update the settings.ini file or just print the changes.',
    ),


    unchanged: Optional[bool] = typer.Option(
        False,
        help='Whether to print all packages, including the ones whose versions haven\'t changed.',
    ),    
    
):      
    # NOTE: notice that file is `env.mac.yml` and not `env.yml`. Now with Apple Silicon I have 
    #       one env file for more common CUDA versions and one for Apple Silicon.
    cprint('bold cyan', f'Loading environment yaml file {file}...')
    if macos:
        file = to_macos_env_file(file)
        
    with open(file, 'r') as f:
        yml_env = yaml.safe_load(f)

    # NOTE: read in the current dependencies from the conda env.yml file
    cprint('bold cyan', 'Extracting packages and their versions...')
    new_pkgs = CondaDependency.load_yml_dependencies(yml_env[ENV_DEPENDENCIES])

    # NOTE: read in the previous requirements from the settings.ini file
    cprint('bold cyan', 'Loading settings.ini file...')
    ini_cfg = configparser.ConfigParser()
    ini_cfg.read(ini_file)
    
    cprint('bold cyan', 'Comparing the old and new requirements...')    
    old_pkgs = IniRequirement.load_ini_requirements(ini_cfg['DEFAULT'][INI_REQUIREMENTS])

    # NOTE: check for changes
    added, removed, changed, remained = compare_requirements(old_pkgs, new_pkgs)

    # If --unchanged option is given, print unchanged packages as well
    if unchanged:
        print_changes(added, removed, changed, remained)

    else:
        print_changes(added, removed, changed, {})

    if dryrun:
        cprint('bold orange1', 'Dryrun: not updating the settings.ini file.')
        return
    
    # NOTE: update the requirements in the settings.ini file
    cprint('bold cyan', 'Updating the requirements...')    
    ini_cfg['DEFAULT'][INI_REQUIREMENTS] = CondaDependency.dump_ini_requirements(new_pkgs)

    cprint('bold cyan', 'Saving the updated settings.ini file...')
    with open(ini_file, 'w') as f:
        ini_cfg.write(f)

    cprint('bold green', 'Successfully updated the requirements in settings.ini!')

# %% ../nbs/00_core.ipynb 30
def run():     
    app()    
    convert()
