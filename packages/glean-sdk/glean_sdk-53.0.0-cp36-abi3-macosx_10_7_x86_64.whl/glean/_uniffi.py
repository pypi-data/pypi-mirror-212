# This file was autogenerated by some hot garbage in the `uniffi` crate.
# Trust me, you don't want to mess with it!

# Tell mypy (a type checker) to ignore all errors from this file.
# See https://mypy.readthedocs.io/en/stable/config_file.html?highlight=ignore-errors#confval-ignore_errors
# mypy: ignore-errors

# Common helper code.
#
# Ideally this would live in a separate .py file where it can be unittested etc
# in isolation, and perhaps even published as a re-useable package.
#
# However, it's important that the details of how this helper code works (e.g. the
# way that different builtin types are passed across the FFI) exactly match what's
# expected by the rust code on the other side of the interface. In practice right
# now that means coming from the exact some version of `uniffi` that was used to
# compile the rust component. The easiest way to ensure this is to bundle the Python
# helpers directly inline like we're doing here.

import os
import sys
import ctypes
import enum
import struct
import contextlib
import datetime

# Used for default argument values
DEFAULT = object()


class RustBuffer(ctypes.Structure):
    _fields_ = [
        ("capacity", ctypes.c_int32),
        ("len", ctypes.c_int32),
        ("data", ctypes.POINTER(ctypes.c_char)),
    ]

    @staticmethod
    def alloc(size):
        return rust_call(_UniFFILib.ffi_glean_7e63_rustbuffer_alloc, size)

    @staticmethod
    def reserve(rbuf, additional):
        return rust_call(_UniFFILib.ffi_glean_7e63_rustbuffer_reserve, rbuf, additional)

    def free(self):
        return rust_call(_UniFFILib.ffi_glean_7e63_rustbuffer_free, self)

    def __str__(self):
        return "RustBuffer(capacity={}, len={}, data={})".format(
            self.capacity,
            self.len,
            self.data[0:self.len]
        )

    @contextlib.contextmanager
    def allocWithBuilder():
        """Context-manger to allocate a buffer using a RustBufferBuilder.

        The allocated buffer will be automatically freed if an error occurs, ensuring that
        we don't accidentally leak it.
        """
        builder = RustBufferBuilder()
        try:
            yield builder
        except:
            builder.discard()
            raise

    @contextlib.contextmanager
    def consumeWithStream(self):
        """Context-manager to consume a buffer using a RustBufferStream.

        The RustBuffer will be freed once the context-manager exits, ensuring that we don't
        leak it even if an error occurs.
        """
        try:
            s = RustBufferStream(self)
            yield s
            if s.remaining() != 0:
                raise RuntimeError("junk data left in buffer after consuming")
        finally:
            self.free()


class ForeignBytes(ctypes.Structure):
    _fields_ = [
        ("len", ctypes.c_int32),
        ("data", ctypes.POINTER(ctypes.c_char)),
    ]

    def __str__(self):
        return "ForeignBytes(len={}, data={})".format(self.len, self.data[0:self.len])


class RustBufferStream(object):
    """
    Helper for structured reading of bytes from a RustBuffer
    """

    def __init__(self, rbuf):
        self.rbuf = rbuf
        self.offset = 0

    def remaining(self):
        return self.rbuf.len - self.offset

    def _unpack_from(self, size, format):
        if self.offset + size > self.rbuf.len:
            raise InternalError("read past end of rust buffer")
        value = struct.unpack(format, self.rbuf.data[self.offset:self.offset+size])[0]
        self.offset += size
        return value

    def read(self, size):
        if self.offset + size > self.rbuf.len:
            raise InternalError("read past end of rust buffer")
        data = self.rbuf.data[self.offset:self.offset+size]
        self.offset += size
        return data

    def readI8(self):
        return self._unpack_from(1, ">b")

    def readU8(self):
        return self._unpack_from(1, ">B")

    def readI16(self):
        return self._unpack_from(2, ">h")

    def readU16(self):
        return self._unpack_from(2, ">H")

    def readI32(self):
        return self._unpack_from(4, ">i")

    def readU32(self):
        return self._unpack_from(4, ">I")

    def readI64(self):
        return self._unpack_from(8, ">q")

    def readU64(self):
        return self._unpack_from(8, ">Q")

    def readFloat(self):
        v = self._unpack_from(4, ">f")
        return v

    def readDouble(self):
        return self._unpack_from(8, ">d")


class RustBufferBuilder(object):
    """
    Helper for structured writing of bytes into a RustBuffer.
    """

    def __init__(self):
        self.rbuf = RustBuffer.alloc(16)
        self.rbuf.len = 0

    def finalize(self):
        rbuf = self.rbuf
        self.rbuf = None
        return rbuf

    def discard(self):
        if self.rbuf is not None:
            rbuf = self.finalize()
            rbuf.free()

    @contextlib.contextmanager
    def _reserve(self, numBytes):
        if self.rbuf.len + numBytes > self.rbuf.capacity:
            self.rbuf = RustBuffer.reserve(self.rbuf, numBytes)
        yield None
        self.rbuf.len += numBytes

    def _pack_into(self, size, format, value):
        with self._reserve(size):
            # XXX TODO: I feel like I should be able to use `struct.pack_into` here but can't figure it out.
            for i, byte in enumerate(struct.pack(format, value)):
                self.rbuf.data[self.rbuf.len + i] = byte

    def write(self, value):
        with self._reserve(len(value)):
            for i, byte in enumerate(value):
                self.rbuf.data[self.rbuf.len + i] = byte

    def writeI8(self, v):
        self._pack_into(1, ">b", v)

    def writeU8(self, v):
        self._pack_into(1, ">B", v)

    def writeI16(self, v):
        self._pack_into(2, ">h", v)

    def writeU16(self, v):
        self._pack_into(2, ">H", v)

    def writeI32(self, v):
        self._pack_into(4, ">i", v)

    def writeU32(self, v):
        self._pack_into(4, ">I", v)

    def writeI64(self, v):
        self._pack_into(8, ">q", v)

    def writeU64(self, v):
        self._pack_into(8, ">Q", v)

    def writeFloat(self, v):
        self._pack_into(4, ">f", v)

    def writeDouble(self, v):
        self._pack_into(8, ">d", v)
# A handful of classes and functions to support the generated data structures.
# This would be a good candidate for isolating in its own ffi-support lib.

class InternalError(Exception):
    pass

class RustCallStatus(ctypes.Structure):
    """
    Error runtime.
    """
    _fields_ = [
        ("code", ctypes.c_int8),
        ("error_buf", RustBuffer),
    ]

    # These match the values from the uniffi::rustcalls module
    CALL_SUCCESS = 0
    CALL_ERROR = 1
    CALL_PANIC = 2

    def __str__(self):
        if self.code == RustCallStatus.CALL_SUCCESS:
            return "RustCallStatus(CALL_SUCCESS)"
        elif self.code == RustCallStatus.CALL_ERROR:
            return "RustCallStatus(CALL_ERROR)"
        elif self.code == RustCallStatus.CALL_PANIC:
            return "RustCallStatus(CALL_PANIC)"
        else:
            return "RustCallStatus(<invalid code>)"

def rust_call(fn, *args):
    # Call a rust function
    return rust_call_with_error(None, fn, *args)

def rust_call_with_error(error_ffi_converter, fn, *args):
    # Call a rust function and handle any errors
    #
    # This function is used for rust calls that return Result<> and therefore can set the CALL_ERROR status code.
    # error_ffi_converter must be set to the FfiConverter for the error class that corresponds to the result.
    call_status = RustCallStatus(code=RustCallStatus.CALL_SUCCESS, error_buf=RustBuffer(0, 0, None))

    args_with_error = args + (ctypes.byref(call_status),)
    result = fn(*args_with_error)
    if call_status.code == RustCallStatus.CALL_SUCCESS:
        return result
    elif call_status.code == RustCallStatus.CALL_ERROR:
        if error_ffi_converter is None:
            call_status.error_buf.free()
            raise InternalError("rust_call_with_error: CALL_ERROR, but error_ffi_converter is None")
        else:
            raise error_ffi_converter.lift(call_status.error_buf)
    elif call_status.code == RustCallStatus.CALL_PANIC:
        # When the rust code sees a panic, it tries to construct a RustBuffer
        # with the message.  But if that code panics, then it just sends back
        # an empty buffer.
        if call_status.error_buf.len > 0:
            msg = FfiConverterString.lift(call_status.error_buf)
        else:
            msg = "Unknown rust panic"
        raise InternalError(msg)
    else:
        raise InternalError("Invalid RustCallStatus code: {}".format(
            call_status.code))

# A function pointer for a callback as defined by UniFFI.
# Rust definition `fn(handle: u64, method: u32, args: RustBuffer, buf_ptr: *mut RustBuffer) -> int`
FOREIGN_CALLBACK_T = ctypes.CFUNCTYPE(ctypes.c_int, ctypes.c_ulonglong, ctypes.c_ulong, RustBuffer, ctypes.POINTER(RustBuffer))
# Types conforming to `FfiConverterPrimitive` pass themselves directly over the FFI.
class FfiConverterPrimitive:
    @classmethod
    def lift(cls, value):
        return value

    @classmethod
    def lower(cls, value):
        return value

# Helper class for wrapper types that will always go through a RustBuffer.
# Classes should inherit from this and implement the `read` and `write` static methods.
class FfiConverterRustBuffer:
    @classmethod
    def lift(cls, rbuf):
        with rbuf.consumeWithStream() as stream:
            return cls.read(stream)

    @classmethod
    def lower(cls, value):
        with RustBuffer.allocWithBuilder() as builder:
            cls.write(value, builder)
            return builder.finalize()

# Contains loading, initialization code,
# and the FFI Function declarations in a com.sun.jna.Library.
# This is how we find and load the dynamic library provided by the component.
# For now we just look it up by name.
#
# XXX TODO: This will probably grow some magic for resolving megazording in future.
# E.g. we might start by looking for the named component in `libuniffi.so` and if
# that fails, fall back to loading it separately from `lib${componentName}.so`.

from pathlib import Path

def loadIndirect():
    if sys.platform == "darwin":
        libname = "lib{}.dylib"
    elif sys.platform.startswith("win"):
        # As of python3.8, ctypes does not seem to search $PATH when loading DLLs.
        # We could use `os.add_dll_directory` to configure the search path, but
        # it doesn't feel right to mess with application-wide settings. Let's
        # assume that the `.dll` is next to the `.py` file and load by full path.
        libname = os.path.join(
            os.path.dirname(__file__),
            "{}.dll",
        )
    else:
        # Anything else must be an ELF platform - Linux, *BSD, Solaris/illumos
        libname = "lib{}.so"

    lib = libname.format("glean_ffi")
    path = str(Path(__file__).parent / lib)
    return ctypes.cdll.LoadLibrary(path)

# A ctypes library to expose the extern-C FFI definitions.
# This is an implementation detail which will be called internally by the public API.

_UniFFILib = loadIndirect()
_UniFFILib.ffi_glean_7e63_PingType_object_free.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ffi_glean_7e63_PingType_object_free.restype = None
_UniFFILib.glean_7e63_PingType_new.argtypes = (
    RustBuffer,
    ctypes.c_int8,
    ctypes.c_int8,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.glean_7e63_PingType_new.restype = ctypes.c_void_p
_UniFFILib.glean_7e63_PingType_submit.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.glean_7e63_PingType_submit.restype = None
_UniFFILib.ffi_glean_7e63_CounterMetric_object_free.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ffi_glean_7e63_CounterMetric_object_free.restype = None
_UniFFILib.glean_7e63_CounterMetric_new.argtypes = (
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.glean_7e63_CounterMetric_new.restype = ctypes.c_void_p
_UniFFILib.glean_7e63_CounterMetric_add.argtypes = (
    ctypes.c_void_p,
    ctypes.c_int32,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.glean_7e63_CounterMetric_add.restype = None
_UniFFILib.glean_7e63_CounterMetric_test_get_value.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.glean_7e63_CounterMetric_test_get_value.restype = RustBuffer
_UniFFILib.glean_7e63_CounterMetric_test_get_num_recorded_errors.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.glean_7e63_CounterMetric_test_get_num_recorded_errors.restype = ctypes.c_int32
_UniFFILib.ffi_glean_7e63_TimespanMetric_object_free.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ffi_glean_7e63_TimespanMetric_object_free.restype = None
_UniFFILib.glean_7e63_TimespanMetric_new.argtypes = (
    RustBuffer,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.glean_7e63_TimespanMetric_new.restype = ctypes.c_void_p
_UniFFILib.glean_7e63_TimespanMetric_start.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.glean_7e63_TimespanMetric_start.restype = None
_UniFFILib.glean_7e63_TimespanMetric_stop.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.glean_7e63_TimespanMetric_stop.restype = None
_UniFFILib.glean_7e63_TimespanMetric_cancel.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.glean_7e63_TimespanMetric_cancel.restype = None
_UniFFILib.glean_7e63_TimespanMetric_set_raw_nanos.argtypes = (
    ctypes.c_void_p,
    ctypes.c_int64,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.glean_7e63_TimespanMetric_set_raw_nanos.restype = None
_UniFFILib.glean_7e63_TimespanMetric_test_get_value.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.glean_7e63_TimespanMetric_test_get_value.restype = RustBuffer
_UniFFILib.glean_7e63_TimespanMetric_test_get_num_recorded_errors.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.glean_7e63_TimespanMetric_test_get_num_recorded_errors.restype = ctypes.c_int32
_UniFFILib.ffi_glean_7e63_BooleanMetric_object_free.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ffi_glean_7e63_BooleanMetric_object_free.restype = None
_UniFFILib.glean_7e63_BooleanMetric_new.argtypes = (
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.glean_7e63_BooleanMetric_new.restype = ctypes.c_void_p
_UniFFILib.glean_7e63_BooleanMetric_set.argtypes = (
    ctypes.c_void_p,
    ctypes.c_int8,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.glean_7e63_BooleanMetric_set.restype = None
_UniFFILib.glean_7e63_BooleanMetric_test_get_value.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.glean_7e63_BooleanMetric_test_get_value.restype = RustBuffer
_UniFFILib.glean_7e63_BooleanMetric_test_get_num_recorded_errors.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.glean_7e63_BooleanMetric_test_get_num_recorded_errors.restype = ctypes.c_int32
_UniFFILib.ffi_glean_7e63_StringMetric_object_free.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ffi_glean_7e63_StringMetric_object_free.restype = None
_UniFFILib.glean_7e63_StringMetric_new.argtypes = (
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.glean_7e63_StringMetric_new.restype = ctypes.c_void_p
_UniFFILib.glean_7e63_StringMetric_set.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.glean_7e63_StringMetric_set.restype = None
_UniFFILib.glean_7e63_StringMetric_test_get_value.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.glean_7e63_StringMetric_test_get_value.restype = RustBuffer
_UniFFILib.glean_7e63_StringMetric_test_get_num_recorded_errors.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.glean_7e63_StringMetric_test_get_num_recorded_errors.restype = ctypes.c_int32
_UniFFILib.ffi_glean_7e63_LabeledCounter_object_free.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ffi_glean_7e63_LabeledCounter_object_free.restype = None
_UniFFILib.glean_7e63_LabeledCounter_new.argtypes = (
    RustBuffer,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.glean_7e63_LabeledCounter_new.restype = ctypes.c_void_p
_UniFFILib.glean_7e63_LabeledCounter_get.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.glean_7e63_LabeledCounter_get.restype = ctypes.c_void_p
_UniFFILib.glean_7e63_LabeledCounter_test_get_num_recorded_errors.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.glean_7e63_LabeledCounter_test_get_num_recorded_errors.restype = ctypes.c_int32
_UniFFILib.ffi_glean_7e63_LabeledBoolean_object_free.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ffi_glean_7e63_LabeledBoolean_object_free.restype = None
_UniFFILib.glean_7e63_LabeledBoolean_new.argtypes = (
    RustBuffer,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.glean_7e63_LabeledBoolean_new.restype = ctypes.c_void_p
_UniFFILib.glean_7e63_LabeledBoolean_get.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.glean_7e63_LabeledBoolean_get.restype = ctypes.c_void_p
_UniFFILib.glean_7e63_LabeledBoolean_test_get_num_recorded_errors.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.glean_7e63_LabeledBoolean_test_get_num_recorded_errors.restype = ctypes.c_int32
_UniFFILib.ffi_glean_7e63_LabeledString_object_free.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ffi_glean_7e63_LabeledString_object_free.restype = None
_UniFFILib.glean_7e63_LabeledString_new.argtypes = (
    RustBuffer,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.glean_7e63_LabeledString_new.restype = ctypes.c_void_p
_UniFFILib.glean_7e63_LabeledString_get.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.glean_7e63_LabeledString_get.restype = ctypes.c_void_p
_UniFFILib.glean_7e63_LabeledString_test_get_num_recorded_errors.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.glean_7e63_LabeledString_test_get_num_recorded_errors.restype = ctypes.c_int32
_UniFFILib.ffi_glean_7e63_StringListMetric_object_free.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ffi_glean_7e63_StringListMetric_object_free.restype = None
_UniFFILib.glean_7e63_StringListMetric_new.argtypes = (
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.glean_7e63_StringListMetric_new.restype = ctypes.c_void_p
_UniFFILib.glean_7e63_StringListMetric_add.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.glean_7e63_StringListMetric_add.restype = None
_UniFFILib.glean_7e63_StringListMetric_set.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.glean_7e63_StringListMetric_set.restype = None
_UniFFILib.glean_7e63_StringListMetric_test_get_value.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.glean_7e63_StringListMetric_test_get_value.restype = RustBuffer
_UniFFILib.glean_7e63_StringListMetric_test_get_num_recorded_errors.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.glean_7e63_StringListMetric_test_get_num_recorded_errors.restype = ctypes.c_int32
_UniFFILib.ffi_glean_7e63_UrlMetric_object_free.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ffi_glean_7e63_UrlMetric_object_free.restype = None
_UniFFILib.glean_7e63_UrlMetric_new.argtypes = (
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.glean_7e63_UrlMetric_new.restype = ctypes.c_void_p
_UniFFILib.glean_7e63_UrlMetric_set.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.glean_7e63_UrlMetric_set.restype = None
_UniFFILib.glean_7e63_UrlMetric_test_get_value.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.glean_7e63_UrlMetric_test_get_value.restype = RustBuffer
_UniFFILib.glean_7e63_UrlMetric_test_get_num_recorded_errors.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.glean_7e63_UrlMetric_test_get_num_recorded_errors.restype = ctypes.c_int32
_UniFFILib.ffi_glean_7e63_UuidMetric_object_free.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ffi_glean_7e63_UuidMetric_object_free.restype = None
_UniFFILib.glean_7e63_UuidMetric_new.argtypes = (
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.glean_7e63_UuidMetric_new.restype = ctypes.c_void_p
_UniFFILib.glean_7e63_UuidMetric_set.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.glean_7e63_UuidMetric_set.restype = None
_UniFFILib.glean_7e63_UuidMetric_generate_and_set.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.glean_7e63_UuidMetric_generate_and_set.restype = RustBuffer
_UniFFILib.glean_7e63_UuidMetric_test_get_value.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.glean_7e63_UuidMetric_test_get_value.restype = RustBuffer
_UniFFILib.glean_7e63_UuidMetric_test_get_num_recorded_errors.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.glean_7e63_UuidMetric_test_get_num_recorded_errors.restype = ctypes.c_int32
_UniFFILib.ffi_glean_7e63_QuantityMetric_object_free.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ffi_glean_7e63_QuantityMetric_object_free.restype = None
_UniFFILib.glean_7e63_QuantityMetric_new.argtypes = (
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.glean_7e63_QuantityMetric_new.restype = ctypes.c_void_p
_UniFFILib.glean_7e63_QuantityMetric_set.argtypes = (
    ctypes.c_void_p,
    ctypes.c_int64,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.glean_7e63_QuantityMetric_set.restype = None
_UniFFILib.glean_7e63_QuantityMetric_test_get_value.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.glean_7e63_QuantityMetric_test_get_value.restype = RustBuffer
_UniFFILib.glean_7e63_QuantityMetric_test_get_num_recorded_errors.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.glean_7e63_QuantityMetric_test_get_num_recorded_errors.restype = ctypes.c_int32
_UniFFILib.ffi_glean_7e63_TimingDistributionMetric_object_free.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ffi_glean_7e63_TimingDistributionMetric_object_free.restype = None
_UniFFILib.glean_7e63_TimingDistributionMetric_new.argtypes = (
    RustBuffer,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.glean_7e63_TimingDistributionMetric_new.restype = ctypes.c_void_p
_UniFFILib.glean_7e63_TimingDistributionMetric_start.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.glean_7e63_TimingDistributionMetric_start.restype = RustBuffer
_UniFFILib.glean_7e63_TimingDistributionMetric_stop_and_accumulate.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.glean_7e63_TimingDistributionMetric_stop_and_accumulate.restype = None
_UniFFILib.glean_7e63_TimingDistributionMetric_cancel.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.glean_7e63_TimingDistributionMetric_cancel.restype = None
_UniFFILib.glean_7e63_TimingDistributionMetric_accumulate_samples.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.glean_7e63_TimingDistributionMetric_accumulate_samples.restype = None
_UniFFILib.glean_7e63_TimingDistributionMetric_test_get_value.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.glean_7e63_TimingDistributionMetric_test_get_value.restype = RustBuffer
_UniFFILib.glean_7e63_TimingDistributionMetric_test_get_num_recorded_errors.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.glean_7e63_TimingDistributionMetric_test_get_num_recorded_errors.restype = ctypes.c_int32
_UniFFILib.ffi_glean_7e63_MemoryDistributionMetric_object_free.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ffi_glean_7e63_MemoryDistributionMetric_object_free.restype = None
_UniFFILib.glean_7e63_MemoryDistributionMetric_new.argtypes = (
    RustBuffer,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.glean_7e63_MemoryDistributionMetric_new.restype = ctypes.c_void_p
_UniFFILib.glean_7e63_MemoryDistributionMetric_accumulate.argtypes = (
    ctypes.c_void_p,
    ctypes.c_int64,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.glean_7e63_MemoryDistributionMetric_accumulate.restype = None
_UniFFILib.glean_7e63_MemoryDistributionMetric_accumulate_samples.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.glean_7e63_MemoryDistributionMetric_accumulate_samples.restype = None
_UniFFILib.glean_7e63_MemoryDistributionMetric_test_get_value.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.glean_7e63_MemoryDistributionMetric_test_get_value.restype = RustBuffer
_UniFFILib.glean_7e63_MemoryDistributionMetric_test_get_num_recorded_errors.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.glean_7e63_MemoryDistributionMetric_test_get_num_recorded_errors.restype = ctypes.c_int32
_UniFFILib.ffi_glean_7e63_CustomDistributionMetric_object_free.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ffi_glean_7e63_CustomDistributionMetric_object_free.restype = None
_UniFFILib.glean_7e63_CustomDistributionMetric_new.argtypes = (
    RustBuffer,
    ctypes.c_int64,
    ctypes.c_int64,
    ctypes.c_int64,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.glean_7e63_CustomDistributionMetric_new.restype = ctypes.c_void_p
_UniFFILib.glean_7e63_CustomDistributionMetric_accumulate_samples.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.glean_7e63_CustomDistributionMetric_accumulate_samples.restype = None
_UniFFILib.glean_7e63_CustomDistributionMetric_test_get_value.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.glean_7e63_CustomDistributionMetric_test_get_value.restype = RustBuffer
_UniFFILib.glean_7e63_CustomDistributionMetric_test_get_num_recorded_errors.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.glean_7e63_CustomDistributionMetric_test_get_num_recorded_errors.restype = ctypes.c_int32
_UniFFILib.ffi_glean_7e63_DatetimeMetric_object_free.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ffi_glean_7e63_DatetimeMetric_object_free.restype = None
_UniFFILib.glean_7e63_DatetimeMetric_new.argtypes = (
    RustBuffer,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.glean_7e63_DatetimeMetric_new.restype = ctypes.c_void_p
_UniFFILib.glean_7e63_DatetimeMetric_set.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.glean_7e63_DatetimeMetric_set.restype = None
_UniFFILib.glean_7e63_DatetimeMetric_test_get_value.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.glean_7e63_DatetimeMetric_test_get_value.restype = RustBuffer
_UniFFILib.glean_7e63_DatetimeMetric_test_get_value_as_string.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.glean_7e63_DatetimeMetric_test_get_value_as_string.restype = RustBuffer
_UniFFILib.glean_7e63_DatetimeMetric_test_get_num_recorded_errors.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.glean_7e63_DatetimeMetric_test_get_num_recorded_errors.restype = ctypes.c_int32
_UniFFILib.ffi_glean_7e63_EventMetric_object_free.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ffi_glean_7e63_EventMetric_object_free.restype = None
_UniFFILib.glean_7e63_EventMetric_new.argtypes = (
    RustBuffer,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.glean_7e63_EventMetric_new.restype = ctypes.c_void_p
_UniFFILib.glean_7e63_EventMetric_record.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.glean_7e63_EventMetric_record.restype = None
_UniFFILib.glean_7e63_EventMetric_test_get_value.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.glean_7e63_EventMetric_test_get_value.restype = RustBuffer
_UniFFILib.glean_7e63_EventMetric_test_get_num_recorded_errors.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.glean_7e63_EventMetric_test_get_num_recorded_errors.restype = ctypes.c_int32
_UniFFILib.ffi_glean_7e63_RateMetric_object_free.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ffi_glean_7e63_RateMetric_object_free.restype = None
_UniFFILib.glean_7e63_RateMetric_new.argtypes = (
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.glean_7e63_RateMetric_new.restype = ctypes.c_void_p
_UniFFILib.glean_7e63_RateMetric_add_to_numerator.argtypes = (
    ctypes.c_void_p,
    ctypes.c_int32,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.glean_7e63_RateMetric_add_to_numerator.restype = None
_UniFFILib.glean_7e63_RateMetric_add_to_denominator.argtypes = (
    ctypes.c_void_p,
    ctypes.c_int32,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.glean_7e63_RateMetric_add_to_denominator.restype = None
_UniFFILib.glean_7e63_RateMetric_test_get_value.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.glean_7e63_RateMetric_test_get_value.restype = RustBuffer
_UniFFILib.glean_7e63_RateMetric_test_get_num_recorded_errors.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.glean_7e63_RateMetric_test_get_num_recorded_errors.restype = ctypes.c_int32
_UniFFILib.ffi_glean_7e63_DenominatorMetric_object_free.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ffi_glean_7e63_DenominatorMetric_object_free.restype = None
_UniFFILib.glean_7e63_DenominatorMetric_new.argtypes = (
    RustBuffer,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.glean_7e63_DenominatorMetric_new.restype = ctypes.c_void_p
_UniFFILib.glean_7e63_DenominatorMetric_add.argtypes = (
    ctypes.c_void_p,
    ctypes.c_int32,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.glean_7e63_DenominatorMetric_add.restype = None
_UniFFILib.glean_7e63_DenominatorMetric_test_get_value.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.glean_7e63_DenominatorMetric_test_get_value.restype = RustBuffer
_UniFFILib.glean_7e63_DenominatorMetric_test_get_num_recorded_errors.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.glean_7e63_DenominatorMetric_test_get_num_recorded_errors.restype = ctypes.c_int32
_UniFFILib.ffi_glean_7e63_NumeratorMetric_object_free.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ffi_glean_7e63_NumeratorMetric_object_free.restype = None
_UniFFILib.glean_7e63_NumeratorMetric_new.argtypes = (
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.glean_7e63_NumeratorMetric_new.restype = ctypes.c_void_p
_UniFFILib.glean_7e63_NumeratorMetric_add_to_numerator.argtypes = (
    ctypes.c_void_p,
    ctypes.c_int32,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.glean_7e63_NumeratorMetric_add_to_numerator.restype = None
_UniFFILib.glean_7e63_NumeratorMetric_test_get_value.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.glean_7e63_NumeratorMetric_test_get_value.restype = RustBuffer
_UniFFILib.glean_7e63_NumeratorMetric_test_get_num_recorded_errors.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.glean_7e63_NumeratorMetric_test_get_num_recorded_errors.restype = ctypes.c_int32
_UniFFILib.ffi_glean_7e63_TextMetric_object_free.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ffi_glean_7e63_TextMetric_object_free.restype = None
_UniFFILib.glean_7e63_TextMetric_new.argtypes = (
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.glean_7e63_TextMetric_new.restype = ctypes.c_void_p
_UniFFILib.glean_7e63_TextMetric_set.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.glean_7e63_TextMetric_set.restype = None
_UniFFILib.glean_7e63_TextMetric_test_get_value.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.glean_7e63_TextMetric_test_get_value.restype = RustBuffer
_UniFFILib.glean_7e63_TextMetric_test_get_num_recorded_errors.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.glean_7e63_TextMetric_test_get_num_recorded_errors.restype = ctypes.c_int32
_UniFFILib.ffi_glean_7e63_OnGleanEvents_init_callback.argtypes = (
    FOREIGN_CALLBACK_T,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ffi_glean_7e63_OnGleanEvents_init_callback.restype = None
_UniFFILib.glean_7e63_glean_enable_logging.argtypes = (
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.glean_7e63_glean_enable_logging.restype = None
_UniFFILib.glean_7e63_glean_enable_logging_to_fd.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.glean_7e63_glean_enable_logging_to_fd.restype = None
_UniFFILib.glean_7e63_glean_initialize.argtypes = (
    RustBuffer,
    RustBuffer,
    ctypes.c_uint64,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.glean_7e63_glean_initialize.restype = None
_UniFFILib.glean_7e63_glean_shutdown.argtypes = (
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.glean_7e63_glean_shutdown.restype = None
_UniFFILib.glean_7e63_glean_initialize_for_subprocess.argtypes = (
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.glean_7e63_glean_initialize_for_subprocess.restype = ctypes.c_int8
_UniFFILib.glean_7e63_glean_set_upload_enabled.argtypes = (
    ctypes.c_int8,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.glean_7e63_glean_set_upload_enabled.restype = None
_UniFFILib.glean_7e63_glean_set_experiment_active.argtypes = (
    RustBuffer,
    RustBuffer,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.glean_7e63_glean_set_experiment_active.restype = None
_UniFFILib.glean_7e63_glean_set_experiment_inactive.argtypes = (
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.glean_7e63_glean_set_experiment_inactive.restype = None
_UniFFILib.glean_7e63_glean_test_get_experiment_data.argtypes = (
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.glean_7e63_glean_test_get_experiment_data.restype = RustBuffer
_UniFFILib.glean_7e63_glean_set_metrics_enabled_config.argtypes = (
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.glean_7e63_glean_set_metrics_enabled_config.restype = None
_UniFFILib.glean_7e63_glean_set_debug_view_tag.argtypes = (
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.glean_7e63_glean_set_debug_view_tag.restype = ctypes.c_int8
_UniFFILib.glean_7e63_glean_set_source_tags.argtypes = (
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.glean_7e63_glean_set_source_tags.restype = ctypes.c_int8
_UniFFILib.glean_7e63_glean_set_log_pings.argtypes = (
    ctypes.c_int8,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.glean_7e63_glean_set_log_pings.restype = None
_UniFFILib.glean_7e63_glean_handle_client_active.argtypes = (
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.glean_7e63_glean_handle_client_active.restype = None
_UniFFILib.glean_7e63_glean_handle_client_inactive.argtypes = (
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.glean_7e63_glean_handle_client_inactive.restype = None
_UniFFILib.glean_7e63_glean_submit_ping_by_name.argtypes = (
    RustBuffer,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.glean_7e63_glean_submit_ping_by_name.restype = None
_UniFFILib.glean_7e63_glean_submit_ping_by_name_sync.argtypes = (
    RustBuffer,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.glean_7e63_glean_submit_ping_by_name_sync.restype = ctypes.c_int8
_UniFFILib.glean_7e63_glean_set_test_mode.argtypes = (
    ctypes.c_int8,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.glean_7e63_glean_set_test_mode.restype = None
_UniFFILib.glean_7e63_glean_test_destroy_glean.argtypes = (
    ctypes.c_int8,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.glean_7e63_glean_test_destroy_glean.restype = None
_UniFFILib.glean_7e63_glean_set_dirty_flag.argtypes = (
    ctypes.c_int8,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.glean_7e63_glean_set_dirty_flag.restype = None
_UniFFILib.glean_7e63_glean_get_upload_task.argtypes = (
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.glean_7e63_glean_get_upload_task.restype = RustBuffer
_UniFFILib.glean_7e63_glean_process_ping_upload_response.argtypes = (
    RustBuffer,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.glean_7e63_glean_process_ping_upload_response.restype = RustBuffer
_UniFFILib.ffi_glean_7e63_rustbuffer_alloc.argtypes = (
    ctypes.c_int32,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ffi_glean_7e63_rustbuffer_alloc.restype = RustBuffer
_UniFFILib.ffi_glean_7e63_rustbuffer_from_bytes.argtypes = (
    ForeignBytes,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ffi_glean_7e63_rustbuffer_from_bytes.restype = RustBuffer
_UniFFILib.ffi_glean_7e63_rustbuffer_free.argtypes = (
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ffi_glean_7e63_rustbuffer_free.restype = None
_UniFFILib.ffi_glean_7e63_rustbuffer_reserve.argtypes = (
    RustBuffer,
    ctypes.c_int32,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ffi_glean_7e63_rustbuffer_reserve.restype = RustBuffer

# Public interface members begin here.


class FfiConverterUInt8(FfiConverterPrimitive):
    @staticmethod
    def read(buf):
        return buf.readU8()

    @staticmethod
    def write(value, buf):
        buf.writeU8(value)

class FfiConverterInt8(FfiConverterPrimitive):
    @staticmethod
    def read(buf):
        return buf.readI8()

    @staticmethod
    def write(value, buf):
        buf.writeI8(value)

class FfiConverterUInt32(FfiConverterPrimitive):
    @staticmethod
    def read(buf):
        return buf.readU32()

    @staticmethod
    def write(value, buf):
        buf.writeU32(value)

class FfiConverterInt32(FfiConverterPrimitive):
    @staticmethod
    def read(buf):
        return buf.readI32()

    @staticmethod
    def write(value, buf):
        buf.writeI32(value)

class FfiConverterUInt64(FfiConverterPrimitive):
    @staticmethod
    def read(buf):
        return buf.readU64()

    @staticmethod
    def write(value, buf):
        buf.writeU64(value)

class FfiConverterInt64(FfiConverterPrimitive):
    @staticmethod
    def read(buf):
        return buf.readI64()

    @staticmethod
    def write(value, buf):
        buf.writeI64(value)

class FfiConverterBool:
    @classmethod
    def read(cls, buf):
        return cls.lift(buf.readU8())

    @classmethod
    def write(cls, value, buf):
        buf.writeU8(cls.lower(value))

    @staticmethod
    def lift(value):
        return int(value) != 0

    @staticmethod
    def lower(value):
        return 1 if value else 0

class FfiConverterString:
    @staticmethod
    def read(buf):
        size = buf.readI32()
        if size < 0:
            raise InternalError("Unexpected negative string length")
        utf8Bytes = buf.read(size)
        return utf8Bytes.decode("utf-8")

    @staticmethod
    def write(value, buf):
        utf8Bytes = value.encode("utf-8")
        buf.writeI32(len(utf8Bytes))
        buf.write(utf8Bytes)

    @staticmethod
    def lift(buf):
        with buf.consumeWithStream() as stream:
            return stream.read(stream.remaining()).decode("utf-8")

    @staticmethod
    def lower(value):
        with RustBuffer.allocWithBuilder() as builder:
            builder.write(value.encode("utf-8"))
            return builder.finalize()



class BooleanMetric(object):
    def __init__(self, meta):
        meta = meta
        
        self._pointer = rust_call(_UniFFILib.glean_7e63_BooleanMetric_new,
        FfiConverterTypeCommonMetricData.lower(meta))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            rust_call(_UniFFILib.ffi_glean_7e63_BooleanMetric_object_free, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    

    def set(self, value):
        value = bool(value)
        
        rust_call(_UniFFILib.glean_7e63_BooleanMetric_set,self._pointer,
        FfiConverterBool.lower(value))
    
    def test_get_value(self, ping_name = DEFAULT):
        if ping_name is DEFAULT:
            ping_name = None
        else:
            ping_name = (None if ping_name is None else ping_name)
        
        return FfiConverterOptionalBool.lift(
            rust_call(_UniFFILib.glean_7e63_BooleanMetric_test_get_value,self._pointer,
        FfiConverterOptionalString.lower(ping_name))
        )
    def test_get_num_recorded_errors(self, error):
        error = error
        
        return FfiConverterInt32.lift(
            rust_call(_UniFFILib.glean_7e63_BooleanMetric_test_get_num_recorded_errors,self._pointer,
        FfiConverterTypeErrorType.lower(error))
        )
    


class FfiConverterTypeBooleanMetric:
    @classmethod
    def read(cls, buf):
        ptr = buf.readU64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, BooleanMetric):
            raise TypeError("Expected BooleanMetric instance, {} found".format(value.__class__.__name__))
        buf.writeU64(cls.lower(value))

    @staticmethod
    def lift(value):
        return BooleanMetric._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class CounterMetric(object):
    def __init__(self, meta):
        meta = meta
        
        self._pointer = rust_call(_UniFFILib.glean_7e63_CounterMetric_new,
        FfiConverterTypeCommonMetricData.lower(meta))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            rust_call(_UniFFILib.ffi_glean_7e63_CounterMetric_object_free, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    

    def add(self, amount = DEFAULT):
        if amount is DEFAULT:
            amount = 1
        else:
            amount = int(amount)
        
        rust_call(_UniFFILib.glean_7e63_CounterMetric_add,self._pointer,
        FfiConverterInt32.lower(amount))
    
    def test_get_value(self, ping_name = DEFAULT):
        if ping_name is DEFAULT:
            ping_name = None
        else:
            ping_name = (None if ping_name is None else ping_name)
        
        return FfiConverterOptionalInt32.lift(
            rust_call(_UniFFILib.glean_7e63_CounterMetric_test_get_value,self._pointer,
        FfiConverterOptionalString.lower(ping_name))
        )
    def test_get_num_recorded_errors(self, error):
        error = error
        
        return FfiConverterInt32.lift(
            rust_call(_UniFFILib.glean_7e63_CounterMetric_test_get_num_recorded_errors,self._pointer,
        FfiConverterTypeErrorType.lower(error))
        )
    


class FfiConverterTypeCounterMetric:
    @classmethod
    def read(cls, buf):
        ptr = buf.readU64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, CounterMetric):
            raise TypeError("Expected CounterMetric instance, {} found".format(value.__class__.__name__))
        buf.writeU64(cls.lower(value))

    @staticmethod
    def lift(value):
        return CounterMetric._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class CustomDistributionMetric(object):
    def __init__(self, meta,range_min,range_max,bucket_count,histogram_type):
        meta = meta
        
        range_min = int(range_min)
        
        range_max = int(range_max)
        
        bucket_count = int(bucket_count)
        
        histogram_type = histogram_type
        
        self._pointer = rust_call(_UniFFILib.glean_7e63_CustomDistributionMetric_new,
        FfiConverterTypeCommonMetricData.lower(meta),
        FfiConverterInt64.lower(range_min),
        FfiConverterInt64.lower(range_max),
        FfiConverterInt64.lower(bucket_count),
        FfiConverterTypeHistogramType.lower(histogram_type))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            rust_call(_UniFFILib.ffi_glean_7e63_CustomDistributionMetric_object_free, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    

    def accumulate_samples(self, samples):
        samples = list(int(x) for x in samples)
        
        rust_call(_UniFFILib.glean_7e63_CustomDistributionMetric_accumulate_samples,self._pointer,
        FfiConverterSequenceInt64.lower(samples))
    
    def test_get_value(self, ping_name = DEFAULT):
        if ping_name is DEFAULT:
            ping_name = None
        else:
            ping_name = (None if ping_name is None else ping_name)
        
        return FfiConverterOptionalTypeDistributionData.lift(
            rust_call(_UniFFILib.glean_7e63_CustomDistributionMetric_test_get_value,self._pointer,
        FfiConverterOptionalString.lower(ping_name))
        )
    def test_get_num_recorded_errors(self, error):
        error = error
        
        return FfiConverterInt32.lift(
            rust_call(_UniFFILib.glean_7e63_CustomDistributionMetric_test_get_num_recorded_errors,self._pointer,
        FfiConverterTypeErrorType.lower(error))
        )
    


class FfiConverterTypeCustomDistributionMetric:
    @classmethod
    def read(cls, buf):
        ptr = buf.readU64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, CustomDistributionMetric):
            raise TypeError("Expected CustomDistributionMetric instance, {} found".format(value.__class__.__name__))
        buf.writeU64(cls.lower(value))

    @staticmethod
    def lift(value):
        return CustomDistributionMetric._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class DatetimeMetric(object):
    def __init__(self, meta,time_unit):
        meta = meta
        
        time_unit = time_unit
        
        self._pointer = rust_call(_UniFFILib.glean_7e63_DatetimeMetric_new,
        FfiConverterTypeCommonMetricData.lower(meta),
        FfiConverterTypeTimeUnit.lower(time_unit))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            rust_call(_UniFFILib.ffi_glean_7e63_DatetimeMetric_object_free, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    

    def set(self, value = DEFAULT):
        if value is DEFAULT:
            value = None
        else:
            value = (None if value is None else value)
        
        rust_call(_UniFFILib.glean_7e63_DatetimeMetric_set,self._pointer,
        FfiConverterOptionalTypeDatetime.lower(value))
    
    def test_get_value(self, ping_name = DEFAULT):
        if ping_name is DEFAULT:
            ping_name = None
        else:
            ping_name = (None if ping_name is None else ping_name)
        
        return FfiConverterOptionalTypeDatetime.lift(
            rust_call(_UniFFILib.glean_7e63_DatetimeMetric_test_get_value,self._pointer,
        FfiConverterOptionalString.lower(ping_name))
        )
    def test_get_value_as_string(self, ping_name = DEFAULT):
        if ping_name is DEFAULT:
            ping_name = None
        else:
            ping_name = (None if ping_name is None else ping_name)
        
        return FfiConverterOptionalString.lift(
            rust_call(_UniFFILib.glean_7e63_DatetimeMetric_test_get_value_as_string,self._pointer,
        FfiConverterOptionalString.lower(ping_name))
        )
    def test_get_num_recorded_errors(self, error):
        error = error
        
        return FfiConverterInt32.lift(
            rust_call(_UniFFILib.glean_7e63_DatetimeMetric_test_get_num_recorded_errors,self._pointer,
        FfiConverterTypeErrorType.lower(error))
        )
    


class FfiConverterTypeDatetimeMetric:
    @classmethod
    def read(cls, buf):
        ptr = buf.readU64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, DatetimeMetric):
            raise TypeError("Expected DatetimeMetric instance, {} found".format(value.__class__.__name__))
        buf.writeU64(cls.lower(value))

    @staticmethod
    def lift(value):
        return DatetimeMetric._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class DenominatorMetric(object):
    def __init__(self, meta,numerators):
        meta = meta
        
        numerators = list(x for x in numerators)
        
        self._pointer = rust_call(_UniFFILib.glean_7e63_DenominatorMetric_new,
        FfiConverterTypeCommonMetricData.lower(meta),
        FfiConverterSequenceTypeCommonMetricData.lower(numerators))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            rust_call(_UniFFILib.ffi_glean_7e63_DenominatorMetric_object_free, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    

    def add(self, amount):
        amount = int(amount)
        
        rust_call(_UniFFILib.glean_7e63_DenominatorMetric_add,self._pointer,
        FfiConverterInt32.lower(amount))
    
    def test_get_value(self, ping_name = DEFAULT):
        if ping_name is DEFAULT:
            ping_name = None
        else:
            ping_name = (None if ping_name is None else ping_name)
        
        return FfiConverterOptionalInt32.lift(
            rust_call(_UniFFILib.glean_7e63_DenominatorMetric_test_get_value,self._pointer,
        FfiConverterOptionalString.lower(ping_name))
        )
    def test_get_num_recorded_errors(self, error):
        error = error
        
        return FfiConverterInt32.lift(
            rust_call(_UniFFILib.glean_7e63_DenominatorMetric_test_get_num_recorded_errors,self._pointer,
        FfiConverterTypeErrorType.lower(error))
        )
    


class FfiConverterTypeDenominatorMetric:
    @classmethod
    def read(cls, buf):
        ptr = buf.readU64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, DenominatorMetric):
            raise TypeError("Expected DenominatorMetric instance, {} found".format(value.__class__.__name__))
        buf.writeU64(cls.lower(value))

    @staticmethod
    def lift(value):
        return DenominatorMetric._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class EventMetric(object):
    def __init__(self, meta,allowed_extra_keys):
        meta = meta
        
        allowed_extra_keys = list(x for x in allowed_extra_keys)
        
        self._pointer = rust_call(_UniFFILib.glean_7e63_EventMetric_new,
        FfiConverterTypeCommonMetricData.lower(meta),
        FfiConverterSequenceString.lower(allowed_extra_keys))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            rust_call(_UniFFILib.ffi_glean_7e63_EventMetric_object_free, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    

    def record(self, extra):
        extra = dict((k, v) for (k, v) in extra.items())
        
        rust_call(_UniFFILib.glean_7e63_EventMetric_record,self._pointer,
        FfiConverterMapStringString.lower(extra))
    
    def test_get_value(self, ping_name = DEFAULT):
        if ping_name is DEFAULT:
            ping_name = None
        else:
            ping_name = (None if ping_name is None else ping_name)
        
        return FfiConverterOptionalSequenceTypeRecordedEvent.lift(
            rust_call(_UniFFILib.glean_7e63_EventMetric_test_get_value,self._pointer,
        FfiConverterOptionalString.lower(ping_name))
        )
    def test_get_num_recorded_errors(self, error):
        error = error
        
        return FfiConverterInt32.lift(
            rust_call(_UniFFILib.glean_7e63_EventMetric_test_get_num_recorded_errors,self._pointer,
        FfiConverterTypeErrorType.lower(error))
        )
    


class FfiConverterTypeEventMetric:
    @classmethod
    def read(cls, buf):
        ptr = buf.readU64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, EventMetric):
            raise TypeError("Expected EventMetric instance, {} found".format(value.__class__.__name__))
        buf.writeU64(cls.lower(value))

    @staticmethod
    def lift(value):
        return EventMetric._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class LabeledBoolean(object):
    def __init__(self, meta,labels):
        meta = meta
        
        labels = (None if labels is None else list(x for x in labels))
        
        self._pointer = rust_call(_UniFFILib.glean_7e63_LabeledBoolean_new,
        FfiConverterTypeCommonMetricData.lower(meta),
        FfiConverterOptionalSequenceTypeCowString.lower(labels))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            rust_call(_UniFFILib.ffi_glean_7e63_LabeledBoolean_object_free, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    

    def get(self, label):
        label = label
        
        return FfiConverterTypeBooleanMetric.lift(
            rust_call(_UniFFILib.glean_7e63_LabeledBoolean_get,self._pointer,
        FfiConverterString.lower(label))
        )
    def test_get_num_recorded_errors(self, error):
        error = error
        
        return FfiConverterInt32.lift(
            rust_call(_UniFFILib.glean_7e63_LabeledBoolean_test_get_num_recorded_errors,self._pointer,
        FfiConverterTypeErrorType.lower(error))
        )
    


class FfiConverterTypeLabeledBoolean:
    @classmethod
    def read(cls, buf):
        ptr = buf.readU64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, LabeledBoolean):
            raise TypeError("Expected LabeledBoolean instance, {} found".format(value.__class__.__name__))
        buf.writeU64(cls.lower(value))

    @staticmethod
    def lift(value):
        return LabeledBoolean._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class LabeledCounter(object):
    def __init__(self, meta,labels):
        meta = meta
        
        labels = (None if labels is None else list(x for x in labels))
        
        self._pointer = rust_call(_UniFFILib.glean_7e63_LabeledCounter_new,
        FfiConverterTypeCommonMetricData.lower(meta),
        FfiConverterOptionalSequenceTypeCowString.lower(labels))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            rust_call(_UniFFILib.ffi_glean_7e63_LabeledCounter_object_free, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    

    def get(self, label):
        label = label
        
        return FfiConverterTypeCounterMetric.lift(
            rust_call(_UniFFILib.glean_7e63_LabeledCounter_get,self._pointer,
        FfiConverterString.lower(label))
        )
    def test_get_num_recorded_errors(self, error):
        error = error
        
        return FfiConverterInt32.lift(
            rust_call(_UniFFILib.glean_7e63_LabeledCounter_test_get_num_recorded_errors,self._pointer,
        FfiConverterTypeErrorType.lower(error))
        )
    


class FfiConverterTypeLabeledCounter:
    @classmethod
    def read(cls, buf):
        ptr = buf.readU64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, LabeledCounter):
            raise TypeError("Expected LabeledCounter instance, {} found".format(value.__class__.__name__))
        buf.writeU64(cls.lower(value))

    @staticmethod
    def lift(value):
        return LabeledCounter._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class LabeledString(object):
    def __init__(self, meta,labels):
        meta = meta
        
        labels = (None if labels is None else list(x for x in labels))
        
        self._pointer = rust_call(_UniFFILib.glean_7e63_LabeledString_new,
        FfiConverterTypeCommonMetricData.lower(meta),
        FfiConverterOptionalSequenceTypeCowString.lower(labels))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            rust_call(_UniFFILib.ffi_glean_7e63_LabeledString_object_free, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    

    def get(self, label):
        label = label
        
        return FfiConverterTypeStringMetric.lift(
            rust_call(_UniFFILib.glean_7e63_LabeledString_get,self._pointer,
        FfiConverterString.lower(label))
        )
    def test_get_num_recorded_errors(self, error):
        error = error
        
        return FfiConverterInt32.lift(
            rust_call(_UniFFILib.glean_7e63_LabeledString_test_get_num_recorded_errors,self._pointer,
        FfiConverterTypeErrorType.lower(error))
        )
    


class FfiConverterTypeLabeledString:
    @classmethod
    def read(cls, buf):
        ptr = buf.readU64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, LabeledString):
            raise TypeError("Expected LabeledString instance, {} found".format(value.__class__.__name__))
        buf.writeU64(cls.lower(value))

    @staticmethod
    def lift(value):
        return LabeledString._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class MemoryDistributionMetric(object):
    def __init__(self, meta,memory_unit):
        meta = meta
        
        memory_unit = memory_unit
        
        self._pointer = rust_call(_UniFFILib.glean_7e63_MemoryDistributionMetric_new,
        FfiConverterTypeCommonMetricData.lower(meta),
        FfiConverterTypeMemoryUnit.lower(memory_unit))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            rust_call(_UniFFILib.ffi_glean_7e63_MemoryDistributionMetric_object_free, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    

    def accumulate(self, sample):
        sample = int(sample)
        
        rust_call(_UniFFILib.glean_7e63_MemoryDistributionMetric_accumulate,self._pointer,
        FfiConverterInt64.lower(sample))
    
    def accumulate_samples(self, samples):
        samples = list(int(x) for x in samples)
        
        rust_call(_UniFFILib.glean_7e63_MemoryDistributionMetric_accumulate_samples,self._pointer,
        FfiConverterSequenceInt64.lower(samples))
    
    def test_get_value(self, ping_name = DEFAULT):
        if ping_name is DEFAULT:
            ping_name = None
        else:
            ping_name = (None if ping_name is None else ping_name)
        
        return FfiConverterOptionalTypeDistributionData.lift(
            rust_call(_UniFFILib.glean_7e63_MemoryDistributionMetric_test_get_value,self._pointer,
        FfiConverterOptionalString.lower(ping_name))
        )
    def test_get_num_recorded_errors(self, error):
        error = error
        
        return FfiConverterInt32.lift(
            rust_call(_UniFFILib.glean_7e63_MemoryDistributionMetric_test_get_num_recorded_errors,self._pointer,
        FfiConverterTypeErrorType.lower(error))
        )
    


class FfiConverterTypeMemoryDistributionMetric:
    @classmethod
    def read(cls, buf):
        ptr = buf.readU64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, MemoryDistributionMetric):
            raise TypeError("Expected MemoryDistributionMetric instance, {} found".format(value.__class__.__name__))
        buf.writeU64(cls.lower(value))

    @staticmethod
    def lift(value):
        return MemoryDistributionMetric._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class NumeratorMetric(object):
    def __init__(self, meta):
        meta = meta
        
        self._pointer = rust_call(_UniFFILib.glean_7e63_NumeratorMetric_new,
        FfiConverterTypeCommonMetricData.lower(meta))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            rust_call(_UniFFILib.ffi_glean_7e63_NumeratorMetric_object_free, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    

    def add_to_numerator(self, amount):
        amount = int(amount)
        
        rust_call(_UniFFILib.glean_7e63_NumeratorMetric_add_to_numerator,self._pointer,
        FfiConverterInt32.lower(amount))
    
    def test_get_value(self, ping_name = DEFAULT):
        if ping_name is DEFAULT:
            ping_name = None
        else:
            ping_name = (None if ping_name is None else ping_name)
        
        return FfiConverterOptionalTypeRate.lift(
            rust_call(_UniFFILib.glean_7e63_NumeratorMetric_test_get_value,self._pointer,
        FfiConverterOptionalString.lower(ping_name))
        )
    def test_get_num_recorded_errors(self, error):
        error = error
        
        return FfiConverterInt32.lift(
            rust_call(_UniFFILib.glean_7e63_NumeratorMetric_test_get_num_recorded_errors,self._pointer,
        FfiConverterTypeErrorType.lower(error))
        )
    


class FfiConverterTypeNumeratorMetric:
    @classmethod
    def read(cls, buf):
        ptr = buf.readU64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, NumeratorMetric):
            raise TypeError("Expected NumeratorMetric instance, {} found".format(value.__class__.__name__))
        buf.writeU64(cls.lower(value))

    @staticmethod
    def lift(value):
        return NumeratorMetric._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class PingType(object):
    def __init__(self, name,include_client_id,send_if_empty,reason_codes):
        name = name
        
        include_client_id = bool(include_client_id)
        
        send_if_empty = bool(send_if_empty)
        
        reason_codes = list(x for x in reason_codes)
        
        self._pointer = rust_call(_UniFFILib.glean_7e63_PingType_new,
        FfiConverterString.lower(name),
        FfiConverterBool.lower(include_client_id),
        FfiConverterBool.lower(send_if_empty),
        FfiConverterSequenceString.lower(reason_codes))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            rust_call(_UniFFILib.ffi_glean_7e63_PingType_object_free, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    

    def submit(self, reason = DEFAULT):
        if reason is DEFAULT:
            reason = None
        else:
            reason = (None if reason is None else reason)
        
        rust_call(_UniFFILib.glean_7e63_PingType_submit,self._pointer,
        FfiConverterOptionalString.lower(reason))
    
    


class FfiConverterTypePingType:
    @classmethod
    def read(cls, buf):
        ptr = buf.readU64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, PingType):
            raise TypeError("Expected PingType instance, {} found".format(value.__class__.__name__))
        buf.writeU64(cls.lower(value))

    @staticmethod
    def lift(value):
        return PingType._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class QuantityMetric(object):
    def __init__(self, meta):
        meta = meta
        
        self._pointer = rust_call(_UniFFILib.glean_7e63_QuantityMetric_new,
        FfiConverterTypeCommonMetricData.lower(meta))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            rust_call(_UniFFILib.ffi_glean_7e63_QuantityMetric_object_free, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    

    def set(self, value):
        value = int(value)
        
        rust_call(_UniFFILib.glean_7e63_QuantityMetric_set,self._pointer,
        FfiConverterInt64.lower(value))
    
    def test_get_value(self, ping_name = DEFAULT):
        if ping_name is DEFAULT:
            ping_name = None
        else:
            ping_name = (None if ping_name is None else ping_name)
        
        return FfiConverterOptionalInt64.lift(
            rust_call(_UniFFILib.glean_7e63_QuantityMetric_test_get_value,self._pointer,
        FfiConverterOptionalString.lower(ping_name))
        )
    def test_get_num_recorded_errors(self, error):
        error = error
        
        return FfiConverterInt32.lift(
            rust_call(_UniFFILib.glean_7e63_QuantityMetric_test_get_num_recorded_errors,self._pointer,
        FfiConverterTypeErrorType.lower(error))
        )
    


class FfiConverterTypeQuantityMetric:
    @classmethod
    def read(cls, buf):
        ptr = buf.readU64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, QuantityMetric):
            raise TypeError("Expected QuantityMetric instance, {} found".format(value.__class__.__name__))
        buf.writeU64(cls.lower(value))

    @staticmethod
    def lift(value):
        return QuantityMetric._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class RateMetric(object):
    def __init__(self, meta):
        meta = meta
        
        self._pointer = rust_call(_UniFFILib.glean_7e63_RateMetric_new,
        FfiConverterTypeCommonMetricData.lower(meta))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            rust_call(_UniFFILib.ffi_glean_7e63_RateMetric_object_free, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    

    def add_to_numerator(self, amount):
        amount = int(amount)
        
        rust_call(_UniFFILib.glean_7e63_RateMetric_add_to_numerator,self._pointer,
        FfiConverterInt32.lower(amount))
    
    def add_to_denominator(self, amount):
        amount = int(amount)
        
        rust_call(_UniFFILib.glean_7e63_RateMetric_add_to_denominator,self._pointer,
        FfiConverterInt32.lower(amount))
    
    def test_get_value(self, ping_name = DEFAULT):
        if ping_name is DEFAULT:
            ping_name = None
        else:
            ping_name = (None if ping_name is None else ping_name)
        
        return FfiConverterOptionalTypeRate.lift(
            rust_call(_UniFFILib.glean_7e63_RateMetric_test_get_value,self._pointer,
        FfiConverterOptionalString.lower(ping_name))
        )
    def test_get_num_recorded_errors(self, error):
        error = error
        
        return FfiConverterInt32.lift(
            rust_call(_UniFFILib.glean_7e63_RateMetric_test_get_num_recorded_errors,self._pointer,
        FfiConverterTypeErrorType.lower(error))
        )
    


class FfiConverterTypeRateMetric:
    @classmethod
    def read(cls, buf):
        ptr = buf.readU64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, RateMetric):
            raise TypeError("Expected RateMetric instance, {} found".format(value.__class__.__name__))
        buf.writeU64(cls.lower(value))

    @staticmethod
    def lift(value):
        return RateMetric._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class StringListMetric(object):
    def __init__(self, meta):
        meta = meta
        
        self._pointer = rust_call(_UniFFILib.glean_7e63_StringListMetric_new,
        FfiConverterTypeCommonMetricData.lower(meta))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            rust_call(_UniFFILib.ffi_glean_7e63_StringListMetric_object_free, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    

    def add(self, value):
        value = value
        
        rust_call(_UniFFILib.glean_7e63_StringListMetric_add,self._pointer,
        FfiConverterString.lower(value))
    
    def set(self, value):
        value = list(x for x in value)
        
        rust_call(_UniFFILib.glean_7e63_StringListMetric_set,self._pointer,
        FfiConverterSequenceString.lower(value))
    
    def test_get_value(self, ping_name = DEFAULT):
        if ping_name is DEFAULT:
            ping_name = None
        else:
            ping_name = (None if ping_name is None else ping_name)
        
        return FfiConverterOptionalSequenceString.lift(
            rust_call(_UniFFILib.glean_7e63_StringListMetric_test_get_value,self._pointer,
        FfiConverterOptionalString.lower(ping_name))
        )
    def test_get_num_recorded_errors(self, error):
        error = error
        
        return FfiConverterInt32.lift(
            rust_call(_UniFFILib.glean_7e63_StringListMetric_test_get_num_recorded_errors,self._pointer,
        FfiConverterTypeErrorType.lower(error))
        )
    


class FfiConverterTypeStringListMetric:
    @classmethod
    def read(cls, buf):
        ptr = buf.readU64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, StringListMetric):
            raise TypeError("Expected StringListMetric instance, {} found".format(value.__class__.__name__))
        buf.writeU64(cls.lower(value))

    @staticmethod
    def lift(value):
        return StringListMetric._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class StringMetric(object):
    def __init__(self, meta):
        meta = meta
        
        self._pointer = rust_call(_UniFFILib.glean_7e63_StringMetric_new,
        FfiConverterTypeCommonMetricData.lower(meta))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            rust_call(_UniFFILib.ffi_glean_7e63_StringMetric_object_free, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    

    def set(self, value):
        value = value
        
        rust_call(_UniFFILib.glean_7e63_StringMetric_set,self._pointer,
        FfiConverterString.lower(value))
    
    def test_get_value(self, ping_name = DEFAULT):
        if ping_name is DEFAULT:
            ping_name = None
        else:
            ping_name = (None if ping_name is None else ping_name)
        
        return FfiConverterOptionalString.lift(
            rust_call(_UniFFILib.glean_7e63_StringMetric_test_get_value,self._pointer,
        FfiConverterOptionalString.lower(ping_name))
        )
    def test_get_num_recorded_errors(self, error):
        error = error
        
        return FfiConverterInt32.lift(
            rust_call(_UniFFILib.glean_7e63_StringMetric_test_get_num_recorded_errors,self._pointer,
        FfiConverterTypeErrorType.lower(error))
        )
    


class FfiConverterTypeStringMetric:
    @classmethod
    def read(cls, buf):
        ptr = buf.readU64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, StringMetric):
            raise TypeError("Expected StringMetric instance, {} found".format(value.__class__.__name__))
        buf.writeU64(cls.lower(value))

    @staticmethod
    def lift(value):
        return StringMetric._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class TextMetric(object):
    def __init__(self, meta):
        meta = meta
        
        self._pointer = rust_call(_UniFFILib.glean_7e63_TextMetric_new,
        FfiConverterTypeCommonMetricData.lower(meta))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            rust_call(_UniFFILib.ffi_glean_7e63_TextMetric_object_free, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    

    def set(self, value):
        value = value
        
        rust_call(_UniFFILib.glean_7e63_TextMetric_set,self._pointer,
        FfiConverterString.lower(value))
    
    def test_get_value(self, ping_name = DEFAULT):
        if ping_name is DEFAULT:
            ping_name = None
        else:
            ping_name = (None if ping_name is None else ping_name)
        
        return FfiConverterOptionalString.lift(
            rust_call(_UniFFILib.glean_7e63_TextMetric_test_get_value,self._pointer,
        FfiConverterOptionalString.lower(ping_name))
        )
    def test_get_num_recorded_errors(self, error):
        error = error
        
        return FfiConverterInt32.lift(
            rust_call(_UniFFILib.glean_7e63_TextMetric_test_get_num_recorded_errors,self._pointer,
        FfiConverterTypeErrorType.lower(error))
        )
    


class FfiConverterTypeTextMetric:
    @classmethod
    def read(cls, buf):
        ptr = buf.readU64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, TextMetric):
            raise TypeError("Expected TextMetric instance, {} found".format(value.__class__.__name__))
        buf.writeU64(cls.lower(value))

    @staticmethod
    def lift(value):
        return TextMetric._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class TimespanMetric(object):
    def __init__(self, meta,time_unit):
        meta = meta
        
        time_unit = time_unit
        
        self._pointer = rust_call(_UniFFILib.glean_7e63_TimespanMetric_new,
        FfiConverterTypeCommonMetricData.lower(meta),
        FfiConverterTypeTimeUnit.lower(time_unit))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            rust_call(_UniFFILib.ffi_glean_7e63_TimespanMetric_object_free, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    

    def start(self, ):
        rust_call(_UniFFILib.glean_7e63_TimespanMetric_start,self._pointer,)
    
    def stop(self, ):
        rust_call(_UniFFILib.glean_7e63_TimespanMetric_stop,self._pointer,)
    
    def cancel(self, ):
        rust_call(_UniFFILib.glean_7e63_TimespanMetric_cancel,self._pointer,)
    
    def set_raw_nanos(self, elapsed):
        elapsed = int(elapsed)
        
        rust_call(_UniFFILib.glean_7e63_TimespanMetric_set_raw_nanos,self._pointer,
        FfiConverterInt64.lower(elapsed))
    
    def test_get_value(self, ping_name = DEFAULT):
        if ping_name is DEFAULT:
            ping_name = None
        else:
            ping_name = (None if ping_name is None else ping_name)
        
        return FfiConverterOptionalInt64.lift(
            rust_call(_UniFFILib.glean_7e63_TimespanMetric_test_get_value,self._pointer,
        FfiConverterOptionalString.lower(ping_name))
        )
    def test_get_num_recorded_errors(self, error):
        error = error
        
        return FfiConverterInt32.lift(
            rust_call(_UniFFILib.glean_7e63_TimespanMetric_test_get_num_recorded_errors,self._pointer,
        FfiConverterTypeErrorType.lower(error))
        )
    


class FfiConverterTypeTimespanMetric:
    @classmethod
    def read(cls, buf):
        ptr = buf.readU64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, TimespanMetric):
            raise TypeError("Expected TimespanMetric instance, {} found".format(value.__class__.__name__))
        buf.writeU64(cls.lower(value))

    @staticmethod
    def lift(value):
        return TimespanMetric._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class TimingDistributionMetric(object):
    def __init__(self, meta,time_unit):
        meta = meta
        
        time_unit = time_unit
        
        self._pointer = rust_call(_UniFFILib.glean_7e63_TimingDistributionMetric_new,
        FfiConverterTypeCommonMetricData.lower(meta),
        FfiConverterTypeTimeUnit.lower(time_unit))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            rust_call(_UniFFILib.ffi_glean_7e63_TimingDistributionMetric_object_free, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    

    def start(self, ):
        return FfiConverterTypeTimerId.lift(
            rust_call(_UniFFILib.glean_7e63_TimingDistributionMetric_start,self._pointer,)
        )
    def stop_and_accumulate(self, timer_id):
        timer_id = timer_id
        
        rust_call(_UniFFILib.glean_7e63_TimingDistributionMetric_stop_and_accumulate,self._pointer,
        FfiConverterTypeTimerId.lower(timer_id))
    
    def cancel(self, timer_id):
        timer_id = timer_id
        
        rust_call(_UniFFILib.glean_7e63_TimingDistributionMetric_cancel,self._pointer,
        FfiConverterTypeTimerId.lower(timer_id))
    
    def accumulate_samples(self, samples):
        samples = list(int(x) for x in samples)
        
        rust_call(_UniFFILib.glean_7e63_TimingDistributionMetric_accumulate_samples,self._pointer,
        FfiConverterSequenceInt64.lower(samples))
    
    def test_get_value(self, ping_name = DEFAULT):
        if ping_name is DEFAULT:
            ping_name = None
        else:
            ping_name = (None if ping_name is None else ping_name)
        
        return FfiConverterOptionalTypeDistributionData.lift(
            rust_call(_UniFFILib.glean_7e63_TimingDistributionMetric_test_get_value,self._pointer,
        FfiConverterOptionalString.lower(ping_name))
        )
    def test_get_num_recorded_errors(self, error):
        error = error
        
        return FfiConverterInt32.lift(
            rust_call(_UniFFILib.glean_7e63_TimingDistributionMetric_test_get_num_recorded_errors,self._pointer,
        FfiConverterTypeErrorType.lower(error))
        )
    


class FfiConverterTypeTimingDistributionMetric:
    @classmethod
    def read(cls, buf):
        ptr = buf.readU64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, TimingDistributionMetric):
            raise TypeError("Expected TimingDistributionMetric instance, {} found".format(value.__class__.__name__))
        buf.writeU64(cls.lower(value))

    @staticmethod
    def lift(value):
        return TimingDistributionMetric._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class UrlMetric(object):
    def __init__(self, meta):
        meta = meta
        
        self._pointer = rust_call(_UniFFILib.glean_7e63_UrlMetric_new,
        FfiConverterTypeCommonMetricData.lower(meta))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            rust_call(_UniFFILib.ffi_glean_7e63_UrlMetric_object_free, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    

    def set(self, value):
        value = value
        
        rust_call(_UniFFILib.glean_7e63_UrlMetric_set,self._pointer,
        FfiConverterString.lower(value))
    
    def test_get_value(self, ping_name = DEFAULT):
        if ping_name is DEFAULT:
            ping_name = None
        else:
            ping_name = (None if ping_name is None else ping_name)
        
        return FfiConverterOptionalString.lift(
            rust_call(_UniFFILib.glean_7e63_UrlMetric_test_get_value,self._pointer,
        FfiConverterOptionalString.lower(ping_name))
        )
    def test_get_num_recorded_errors(self, error):
        error = error
        
        return FfiConverterInt32.lift(
            rust_call(_UniFFILib.glean_7e63_UrlMetric_test_get_num_recorded_errors,self._pointer,
        FfiConverterTypeErrorType.lower(error))
        )
    


class FfiConverterTypeUrlMetric:
    @classmethod
    def read(cls, buf):
        ptr = buf.readU64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, UrlMetric):
            raise TypeError("Expected UrlMetric instance, {} found".format(value.__class__.__name__))
        buf.writeU64(cls.lower(value))

    @staticmethod
    def lift(value):
        return UrlMetric._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class UuidMetric(object):
    def __init__(self, meta):
        meta = meta
        
        self._pointer = rust_call(_UniFFILib.glean_7e63_UuidMetric_new,
        FfiConverterTypeCommonMetricData.lower(meta))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            rust_call(_UniFFILib.ffi_glean_7e63_UuidMetric_object_free, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    

    def set(self, value):
        value = value
        
        rust_call(_UniFFILib.glean_7e63_UuidMetric_set,self._pointer,
        FfiConverterString.lower(value))
    
    def generate_and_set(self, ):
        return FfiConverterString.lift(
            rust_call(_UniFFILib.glean_7e63_UuidMetric_generate_and_set,self._pointer,)
        )
    def test_get_value(self, ping_name = DEFAULT):
        if ping_name is DEFAULT:
            ping_name = None
        else:
            ping_name = (None if ping_name is None else ping_name)
        
        return FfiConverterOptionalString.lift(
            rust_call(_UniFFILib.glean_7e63_UuidMetric_test_get_value,self._pointer,
        FfiConverterOptionalString.lower(ping_name))
        )
    def test_get_num_recorded_errors(self, error):
        error = error
        
        return FfiConverterInt32.lift(
            rust_call(_UniFFILib.glean_7e63_UuidMetric_test_get_num_recorded_errors,self._pointer,
        FfiConverterTypeErrorType.lower(error))
        )
    


class FfiConverterTypeUuidMetric:
    @classmethod
    def read(cls, buf):
        ptr = buf.readU64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, UuidMetric):
            raise TypeError("Expected UuidMetric instance, {} found".format(value.__class__.__name__))
        buf.writeU64(cls.lower(value))

    @staticmethod
    def lift(value):
        return UuidMetric._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer


class ClientInfoMetrics:

    def __init__(self, app_build, app_display_version, app_build_date, architecture, os_version, channel = DEFAULT, locale = DEFAULT, device_manufacturer = DEFAULT, device_model = DEFAULT, android_sdk_version = DEFAULT, windows_build_number = DEFAULT):
        self.app_build = app_build
        self.app_display_version = app_display_version
        self.app_build_date = app_build_date
        self.architecture = architecture
        self.os_version = os_version
        if channel is DEFAULT:
            self.channel = None
        else:
            self.channel = channel
        if locale is DEFAULT:
            self.locale = None
        else:
            self.locale = locale
        if device_manufacturer is DEFAULT:
            self.device_manufacturer = None
        else:
            self.device_manufacturer = device_manufacturer
        if device_model is DEFAULT:
            self.device_model = None
        else:
            self.device_model = device_model
        if android_sdk_version is DEFAULT:
            self.android_sdk_version = None
        else:
            self.android_sdk_version = android_sdk_version
        if windows_build_number is DEFAULT:
            self.windows_build_number = None
        else:
            self.windows_build_number = windows_build_number

    def __str__(self):
        return "ClientInfoMetrics(app_build={}, app_display_version={}, app_build_date={}, architecture={}, os_version={}, channel={}, locale={}, device_manufacturer={}, device_model={}, android_sdk_version={}, windows_build_number={})".format(self.app_build, self.app_display_version, self.app_build_date, self.architecture, self.os_version, self.channel, self.locale, self.device_manufacturer, self.device_model, self.android_sdk_version, self.windows_build_number)

    def __eq__(self, other):
        if self.app_build != other.app_build:
            return False
        if self.app_display_version != other.app_display_version:
            return False
        if self.app_build_date != other.app_build_date:
            return False
        if self.architecture != other.architecture:
            return False
        if self.os_version != other.os_version:
            return False
        if self.channel != other.channel:
            return False
        if self.locale != other.locale:
            return False
        if self.device_manufacturer != other.device_manufacturer:
            return False
        if self.device_model != other.device_model:
            return False
        if self.android_sdk_version != other.android_sdk_version:
            return False
        if self.windows_build_number != other.windows_build_number:
            return False
        return True

class FfiConverterTypeClientInfoMetrics(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return ClientInfoMetrics(
            app_build=FfiConverterString.read(buf),
            app_display_version=FfiConverterString.read(buf),
            app_build_date=FfiConverterTypeDatetime.read(buf),
            architecture=FfiConverterString.read(buf),
            os_version=FfiConverterString.read(buf),
            channel=FfiConverterOptionalString.read(buf),
            locale=FfiConverterOptionalString.read(buf),
            device_manufacturer=FfiConverterOptionalString.read(buf),
            device_model=FfiConverterOptionalString.read(buf),
            android_sdk_version=FfiConverterOptionalString.read(buf),
            windows_build_number=FfiConverterOptionalInt64.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterString.write(value.app_build, buf)
        FfiConverterString.write(value.app_display_version, buf)
        FfiConverterTypeDatetime.write(value.app_build_date, buf)
        FfiConverterString.write(value.architecture, buf)
        FfiConverterString.write(value.os_version, buf)
        FfiConverterOptionalString.write(value.channel, buf)
        FfiConverterOptionalString.write(value.locale, buf)
        FfiConverterOptionalString.write(value.device_manufacturer, buf)
        FfiConverterOptionalString.write(value.device_model, buf)
        FfiConverterOptionalString.write(value.android_sdk_version, buf)
        FfiConverterOptionalInt64.write(value.windows_build_number, buf)


class CommonMetricData:

    def __init__(self, category, name, send_in_pings, lifetime, disabled, dynamic_label = DEFAULT):
        self.category = category
        self.name = name
        self.send_in_pings = send_in_pings
        self.lifetime = lifetime
        self.disabled = disabled
        if dynamic_label is DEFAULT:
            self.dynamic_label = None
        else:
            self.dynamic_label = dynamic_label

    def __str__(self):
        return "CommonMetricData(category={}, name={}, send_in_pings={}, lifetime={}, disabled={}, dynamic_label={})".format(self.category, self.name, self.send_in_pings, self.lifetime, self.disabled, self.dynamic_label)

    def __eq__(self, other):
        if self.category != other.category:
            return False
        if self.name != other.name:
            return False
        if self.send_in_pings != other.send_in_pings:
            return False
        if self.lifetime != other.lifetime:
            return False
        if self.disabled != other.disabled:
            return False
        if self.dynamic_label != other.dynamic_label:
            return False
        return True

class FfiConverterTypeCommonMetricData(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return CommonMetricData(
            category=FfiConverterString.read(buf),
            name=FfiConverterString.read(buf),
            send_in_pings=FfiConverterSequenceString.read(buf),
            lifetime=FfiConverterTypeLifetime.read(buf),
            disabled=FfiConverterBool.read(buf),
            dynamic_label=FfiConverterOptionalString.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterString.write(value.category, buf)
        FfiConverterString.write(value.name, buf)
        FfiConverterSequenceString.write(value.send_in_pings, buf)
        FfiConverterTypeLifetime.write(value.lifetime, buf)
        FfiConverterBool.write(value.disabled, buf)
        FfiConverterOptionalString.write(value.dynamic_label, buf)


class Datetime:

    def __init__(self, year, month, day, hour, minute, second, nanosecond, offset_seconds):
        self.year = year
        self.month = month
        self.day = day
        self.hour = hour
        self.minute = minute
        self.second = second
        self.nanosecond = nanosecond
        self.offset_seconds = offset_seconds

    def __str__(self):
        return "Datetime(year={}, month={}, day={}, hour={}, minute={}, second={}, nanosecond={}, offset_seconds={})".format(self.year, self.month, self.day, self.hour, self.minute, self.second, self.nanosecond, self.offset_seconds)

    def __eq__(self, other):
        if self.year != other.year:
            return False
        if self.month != other.month:
            return False
        if self.day != other.day:
            return False
        if self.hour != other.hour:
            return False
        if self.minute != other.minute:
            return False
        if self.second != other.second:
            return False
        if self.nanosecond != other.nanosecond:
            return False
        if self.offset_seconds != other.offset_seconds:
            return False
        return True

class FfiConverterTypeDatetime(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return Datetime(
            year=FfiConverterInt32.read(buf),
            month=FfiConverterUInt32.read(buf),
            day=FfiConverterUInt32.read(buf),
            hour=FfiConverterUInt32.read(buf),
            minute=FfiConverterUInt32.read(buf),
            second=FfiConverterUInt32.read(buf),
            nanosecond=FfiConverterUInt32.read(buf),
            offset_seconds=FfiConverterInt32.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterInt32.write(value.year, buf)
        FfiConverterUInt32.write(value.month, buf)
        FfiConverterUInt32.write(value.day, buf)
        FfiConverterUInt32.write(value.hour, buf)
        FfiConverterUInt32.write(value.minute, buf)
        FfiConverterUInt32.write(value.second, buf)
        FfiConverterUInt32.write(value.nanosecond, buf)
        FfiConverterInt32.write(value.offset_seconds, buf)


class DistributionData:

    def __init__(self, values, sum, count):
        self.values = values
        self.sum = sum
        self.count = count

    def __str__(self):
        return "DistributionData(values={}, sum={}, count={})".format(self.values, self.sum, self.count)

    def __eq__(self, other):
        if self.values != other.values:
            return False
        if self.sum != other.sum:
            return False
        if self.count != other.count:
            return False
        return True

class FfiConverterTypeDistributionData(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return DistributionData(
            values=FfiConverterMapInt64Int64.read(buf),
            sum=FfiConverterInt64.read(buf),
            count=FfiConverterInt64.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterMapInt64Int64.write(value.values, buf)
        FfiConverterInt64.write(value.sum, buf)
        FfiConverterInt64.write(value.count, buf)


class InternalConfiguration:

    def __init__(self, data_path, application_id, language_binding_name, upload_enabled, max_events, delay_ping_lifetime_io, app_build, use_core_mps, trim_data_to_registered_pings, log_level, rate_limit):
        self.data_path = data_path
        self.application_id = application_id
        self.language_binding_name = language_binding_name
        self.upload_enabled = upload_enabled
        self.max_events = max_events
        self.delay_ping_lifetime_io = delay_ping_lifetime_io
        self.app_build = app_build
        self.use_core_mps = use_core_mps
        self.trim_data_to_registered_pings = trim_data_to_registered_pings
        self.log_level = log_level
        self.rate_limit = rate_limit

    def __str__(self):
        return "InternalConfiguration(data_path={}, application_id={}, language_binding_name={}, upload_enabled={}, max_events={}, delay_ping_lifetime_io={}, app_build={}, use_core_mps={}, trim_data_to_registered_pings={}, log_level={}, rate_limit={})".format(self.data_path, self.application_id, self.language_binding_name, self.upload_enabled, self.max_events, self.delay_ping_lifetime_io, self.app_build, self.use_core_mps, self.trim_data_to_registered_pings, self.log_level, self.rate_limit)

    def __eq__(self, other):
        if self.data_path != other.data_path:
            return False
        if self.application_id != other.application_id:
            return False
        if self.language_binding_name != other.language_binding_name:
            return False
        if self.upload_enabled != other.upload_enabled:
            return False
        if self.max_events != other.max_events:
            return False
        if self.delay_ping_lifetime_io != other.delay_ping_lifetime_io:
            return False
        if self.app_build != other.app_build:
            return False
        if self.use_core_mps != other.use_core_mps:
            return False
        if self.trim_data_to_registered_pings != other.trim_data_to_registered_pings:
            return False
        if self.log_level != other.log_level:
            return False
        if self.rate_limit != other.rate_limit:
            return False
        return True

class FfiConverterTypeInternalConfiguration(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return InternalConfiguration(
            data_path=FfiConverterString.read(buf),
            application_id=FfiConverterString.read(buf),
            language_binding_name=FfiConverterString.read(buf),
            upload_enabled=FfiConverterBool.read(buf),
            max_events=FfiConverterOptionalUInt32.read(buf),
            delay_ping_lifetime_io=FfiConverterBool.read(buf),
            app_build=FfiConverterString.read(buf),
            use_core_mps=FfiConverterBool.read(buf),
            trim_data_to_registered_pings=FfiConverterBool.read(buf),
            log_level=FfiConverterOptionalTypeLevelFilter.read(buf),
            rate_limit=FfiConverterOptionalTypePingRateLimit.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterString.write(value.data_path, buf)
        FfiConverterString.write(value.application_id, buf)
        FfiConverterString.write(value.language_binding_name, buf)
        FfiConverterBool.write(value.upload_enabled, buf)
        FfiConverterOptionalUInt32.write(value.max_events, buf)
        FfiConverterBool.write(value.delay_ping_lifetime_io, buf)
        FfiConverterString.write(value.app_build, buf)
        FfiConverterBool.write(value.use_core_mps, buf)
        FfiConverterBool.write(value.trim_data_to_registered_pings, buf)
        FfiConverterOptionalTypeLevelFilter.write(value.log_level, buf)
        FfiConverterOptionalTypePingRateLimit.write(value.rate_limit, buf)


class PingRateLimit:

    def __init__(self, seconds_per_interval, pings_per_interval):
        self.seconds_per_interval = seconds_per_interval
        self.pings_per_interval = pings_per_interval

    def __str__(self):
        return "PingRateLimit(seconds_per_interval={}, pings_per_interval={})".format(self.seconds_per_interval, self.pings_per_interval)

    def __eq__(self, other):
        if self.seconds_per_interval != other.seconds_per_interval:
            return False
        if self.pings_per_interval != other.pings_per_interval:
            return False
        return True

class FfiConverterTypePingRateLimit(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return PingRateLimit(
            seconds_per_interval=FfiConverterUInt64.read(buf),
            pings_per_interval=FfiConverterUInt32.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterUInt64.write(value.seconds_per_interval, buf)
        FfiConverterUInt32.write(value.pings_per_interval, buf)


class PingRequest:

    def __init__(self, document_id, path, body, headers):
        self.document_id = document_id
        self.path = path
        self.body = body
        self.headers = headers

    def __str__(self):
        return "PingRequest(document_id={}, path={}, body={}, headers={})".format(self.document_id, self.path, self.body, self.headers)

    def __eq__(self, other):
        if self.document_id != other.document_id:
            return False
        if self.path != other.path:
            return False
        if self.body != other.body:
            return False
        if self.headers != other.headers:
            return False
        return True

class FfiConverterTypePingRequest(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return PingRequest(
            document_id=FfiConverterString.read(buf),
            path=FfiConverterString.read(buf),
            body=FfiConverterSequenceUInt8.read(buf),
            headers=FfiConverterMapStringString.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterString.write(value.document_id, buf)
        FfiConverterString.write(value.path, buf)
        FfiConverterSequenceUInt8.write(value.body, buf)
        FfiConverterMapStringString.write(value.headers, buf)


class Rate:

    def __init__(self, numerator, denominator):
        self.numerator = numerator
        self.denominator = denominator

    def __str__(self):
        return "Rate(numerator={}, denominator={})".format(self.numerator, self.denominator)

    def __eq__(self, other):
        if self.numerator != other.numerator:
            return False
        if self.denominator != other.denominator:
            return False
        return True

class FfiConverterTypeRate(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return Rate(
            numerator=FfiConverterInt32.read(buf),
            denominator=FfiConverterInt32.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterInt32.write(value.numerator, buf)
        FfiConverterInt32.write(value.denominator, buf)


class RecordedEvent:

    def __init__(self, timestamp, category, name, extra):
        self.timestamp = timestamp
        self.category = category
        self.name = name
        self.extra = extra

    def __str__(self):
        return "RecordedEvent(timestamp={}, category={}, name={}, extra={})".format(self.timestamp, self.category, self.name, self.extra)

    def __eq__(self, other):
        if self.timestamp != other.timestamp:
            return False
        if self.category != other.category:
            return False
        if self.name != other.name:
            return False
        if self.extra != other.extra:
            return False
        return True

class FfiConverterTypeRecordedEvent(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return RecordedEvent(
            timestamp=FfiConverterUInt64.read(buf),
            category=FfiConverterString.read(buf),
            name=FfiConverterString.read(buf),
            extra=FfiConverterOptionalMapStringString.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterUInt64.write(value.timestamp, buf)
        FfiConverterString.write(value.category, buf)
        FfiConverterString.write(value.name, buf)
        FfiConverterOptionalMapStringString.write(value.extra, buf)


class RecordedExperiment:

    def __init__(self, branch, extra):
        self.branch = branch
        self.extra = extra

    def __str__(self):
        return "RecordedExperiment(branch={}, extra={})".format(self.branch, self.extra)

    def __eq__(self, other):
        if self.branch != other.branch:
            return False
        if self.extra != other.extra:
            return False
        return True

class FfiConverterTypeRecordedExperiment(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return RecordedExperiment(
            branch=FfiConverterString.read(buf),
            extra=FfiConverterOptionalMapStringString.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterString.write(value.branch, buf)
        FfiConverterOptionalMapStringString.write(value.extra, buf)


class TimerId:

    def __init__(self, id):
        self.id = id

    def __str__(self):
        return "TimerId(id={})".format(self.id)

    def __eq__(self, other):
        if self.id != other.id:
            return False
        return True

class FfiConverterTypeTimerId(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return TimerId(
            id=FfiConverterUInt64.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterUInt64.write(value.id, buf)




class ErrorType(enum.Enum):
    INVALID_VALUE = 1
    INVALID_LABEL = 2
    INVALID_STATE = 3
    INVALID_OVERFLOW = 4
    


class FfiConverterTypeErrorType(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.readI32()
        if variant == 1:
            return ErrorType.INVALID_VALUE
        if variant == 2:
            return ErrorType.INVALID_LABEL
        if variant == 3:
            return ErrorType.INVALID_STATE
        if variant == 4:
            return ErrorType.INVALID_OVERFLOW
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value == ErrorType.INVALID_VALUE:
            buf.writeI32(1)
        if value == ErrorType.INVALID_LABEL:
            buf.writeI32(2)
        if value == ErrorType.INVALID_STATE:
            buf.writeI32(3)
        if value == ErrorType.INVALID_OVERFLOW:
            buf.writeI32(4)




class HistogramType(enum.Enum):
    LINEAR = 1
    EXPONENTIAL = 2
    


class FfiConverterTypeHistogramType(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.readI32()
        if variant == 1:
            return HistogramType.LINEAR
        if variant == 2:
            return HistogramType.EXPONENTIAL
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value == HistogramType.LINEAR:
            buf.writeI32(1)
        if value == HistogramType.EXPONENTIAL:
            buf.writeI32(2)




class LevelFilter(enum.Enum):
    OFF = 1
    ERROR = 2
    WARN = 3
    INFO = 4
    DEBUG = 5
    TRACE = 6
    


class FfiConverterTypeLevelFilter(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.readI32()
        if variant == 1:
            return LevelFilter.OFF
        if variant == 2:
            return LevelFilter.ERROR
        if variant == 3:
            return LevelFilter.WARN
        if variant == 4:
            return LevelFilter.INFO
        if variant == 5:
            return LevelFilter.DEBUG
        if variant == 6:
            return LevelFilter.TRACE
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value == LevelFilter.OFF:
            buf.writeI32(1)
        if value == LevelFilter.ERROR:
            buf.writeI32(2)
        if value == LevelFilter.WARN:
            buf.writeI32(3)
        if value == LevelFilter.INFO:
            buf.writeI32(4)
        if value == LevelFilter.DEBUG:
            buf.writeI32(5)
        if value == LevelFilter.TRACE:
            buf.writeI32(6)




class Lifetime(enum.Enum):
    PING = 1
    APPLICATION = 2
    USER = 3
    


class FfiConverterTypeLifetime(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.readI32()
        if variant == 1:
            return Lifetime.PING
        if variant == 2:
            return Lifetime.APPLICATION
        if variant == 3:
            return Lifetime.USER
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value == Lifetime.PING:
            buf.writeI32(1)
        if value == Lifetime.APPLICATION:
            buf.writeI32(2)
        if value == Lifetime.USER:
            buf.writeI32(3)




class MemoryUnit(enum.Enum):
    BYTE = 1
    KILOBYTE = 2
    MEGABYTE = 3
    GIGABYTE = 4
    


class FfiConverterTypeMemoryUnit(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.readI32()
        if variant == 1:
            return MemoryUnit.BYTE
        if variant == 2:
            return MemoryUnit.KILOBYTE
        if variant == 3:
            return MemoryUnit.MEGABYTE
        if variant == 4:
            return MemoryUnit.GIGABYTE
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value == MemoryUnit.BYTE:
            buf.writeI32(1)
        if value == MemoryUnit.KILOBYTE:
            buf.writeI32(2)
        if value == MemoryUnit.MEGABYTE:
            buf.writeI32(3)
        if value == MemoryUnit.GIGABYTE:
            buf.writeI32(4)




class PingUploadTask:
    def __init__(self):
        raise RuntimeError("PingUploadTask cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class UPLOAD(object):
        def __init__(self,request):
            
            self.request = request
            

        def __str__(self):
            return "PingUploadTask.UPLOAD(request={})".format(self.request)

        def __eq__(self, other):
            if not other.is_upload():
                return False
            if self.request != other.request:
                return False
            return True
    class WAIT(object):
        def __init__(self,time):
            
            self.time = time
            

        def __str__(self):
            return "PingUploadTask.WAIT(time={})".format(self.time)

        def __eq__(self, other):
            if not other.is_wait():
                return False
            if self.time != other.time:
                return False
            return True
    class DONE(object):
        def __init__(self,unused):
            
            self.unused = unused
            

        def __str__(self):
            return "PingUploadTask.DONE(unused={})".format(self.unused)

        def __eq__(self, other):
            if not other.is_done():
                return False
            if self.unused != other.unused:
                return False
            return True
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_upload(self):
        return isinstance(self, PingUploadTask.UPLOAD)
    def is_wait(self):
        return isinstance(self, PingUploadTask.WAIT)
    def is_done(self):
        return isinstance(self, PingUploadTask.DONE)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
PingUploadTask.UPLOAD = type("PingUploadTask.UPLOAD", (PingUploadTask.UPLOAD, PingUploadTask,), {})
PingUploadTask.WAIT = type("PingUploadTask.WAIT", (PingUploadTask.WAIT, PingUploadTask,), {})
PingUploadTask.DONE = type("PingUploadTask.DONE", (PingUploadTask.DONE, PingUploadTask,), {})




class FfiConverterTypePingUploadTask(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.readI32()
        if variant == 1:
            return PingUploadTask.UPLOAD(
                FfiConverterTypePingRequest.read(buf),
            )
        if variant == 2:
            return PingUploadTask.WAIT(
                FfiConverterUInt64.read(buf),
            )
        if variant == 3:
            return PingUploadTask.DONE(
                FfiConverterInt8.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value.is_upload():
            buf.writeI32(1)
            FfiConverterTypePingRequest.write(value.request, buf)
        if value.is_wait():
            buf.writeI32(2)
            FfiConverterUInt64.write(value.time, buf)
        if value.is_done():
            buf.writeI32(3)
            FfiConverterInt8.write(value.unused, buf)




class TimeUnit(enum.Enum):
    NANOSECOND = 1
    MICROSECOND = 2
    MILLISECOND = 3
    SECOND = 4
    MINUTE = 5
    HOUR = 6
    DAY = 7
    


class FfiConverterTypeTimeUnit(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.readI32()
        if variant == 1:
            return TimeUnit.NANOSECOND
        if variant == 2:
            return TimeUnit.MICROSECOND
        if variant == 3:
            return TimeUnit.MILLISECOND
        if variant == 4:
            return TimeUnit.SECOND
        if variant == 5:
            return TimeUnit.MINUTE
        if variant == 6:
            return TimeUnit.HOUR
        if variant == 7:
            return TimeUnit.DAY
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value == TimeUnit.NANOSECOND:
            buf.writeI32(1)
        if value == TimeUnit.MICROSECOND:
            buf.writeI32(2)
        if value == TimeUnit.MILLISECOND:
            buf.writeI32(3)
        if value == TimeUnit.SECOND:
            buf.writeI32(4)
        if value == TimeUnit.MINUTE:
            buf.writeI32(5)
        if value == TimeUnit.HOUR:
            buf.writeI32(6)
        if value == TimeUnit.DAY:
            buf.writeI32(7)




class UploadResult:
    def __init__(self):
        raise RuntimeError("UploadResult cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class RECOVERABLE_FAILURE(object):
        def __init__(self,unused):
            
            self.unused = unused
            

        def __str__(self):
            return "UploadResult.RECOVERABLE_FAILURE(unused={})".format(self.unused)

        def __eq__(self, other):
            if not other.is_recoverable_failure():
                return False
            if self.unused != other.unused:
                return False
            return True
    class UNRECOVERABLE_FAILURE(object):
        def __init__(self,unused):
            
            self.unused = unused
            

        def __str__(self):
            return "UploadResult.UNRECOVERABLE_FAILURE(unused={})".format(self.unused)

        def __eq__(self, other):
            if not other.is_unrecoverable_failure():
                return False
            if self.unused != other.unused:
                return False
            return True
    class HTTP_STATUS(object):
        def __init__(self,code):
            
            self.code = code
            

        def __str__(self):
            return "UploadResult.HTTP_STATUS(code={})".format(self.code)

        def __eq__(self, other):
            if not other.is_http_status():
                return False
            if self.code != other.code:
                return False
            return True
    class DONE(object):
        def __init__(self,unused):
            
            self.unused = unused
            

        def __str__(self):
            return "UploadResult.DONE(unused={})".format(self.unused)

        def __eq__(self, other):
            if not other.is_done():
                return False
            if self.unused != other.unused:
                return False
            return True
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_recoverable_failure(self):
        return isinstance(self, UploadResult.RECOVERABLE_FAILURE)
    def is_unrecoverable_failure(self):
        return isinstance(self, UploadResult.UNRECOVERABLE_FAILURE)
    def is_http_status(self):
        return isinstance(self, UploadResult.HTTP_STATUS)
    def is_done(self):
        return isinstance(self, UploadResult.DONE)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
UploadResult.RECOVERABLE_FAILURE = type("UploadResult.RECOVERABLE_FAILURE", (UploadResult.RECOVERABLE_FAILURE, UploadResult,), {})
UploadResult.UNRECOVERABLE_FAILURE = type("UploadResult.UNRECOVERABLE_FAILURE", (UploadResult.UNRECOVERABLE_FAILURE, UploadResult,), {})
UploadResult.HTTP_STATUS = type("UploadResult.HTTP_STATUS", (UploadResult.HTTP_STATUS, UploadResult,), {})
UploadResult.DONE = type("UploadResult.DONE", (UploadResult.DONE, UploadResult,), {})




class FfiConverterTypeUploadResult(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.readI32()
        if variant == 1:
            return UploadResult.RECOVERABLE_FAILURE(
                FfiConverterInt8.read(buf),
            )
        if variant == 2:
            return UploadResult.UNRECOVERABLE_FAILURE(
                FfiConverterInt8.read(buf),
            )
        if variant == 3:
            return UploadResult.HTTP_STATUS(
                FfiConverterInt32.read(buf),
            )
        if variant == 4:
            return UploadResult.DONE(
                FfiConverterInt8.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value.is_recoverable_failure():
            buf.writeI32(1)
            FfiConverterInt8.write(value.unused, buf)
        if value.is_unrecoverable_failure():
            buf.writeI32(2)
            FfiConverterInt8.write(value.unused, buf)
        if value.is_http_status():
            buf.writeI32(3)
            FfiConverterInt32.write(value.code, buf)
        if value.is_done():
            buf.writeI32(4)
            FfiConverterInt8.write(value.unused, buf)




class UploadTaskAction(enum.Enum):
    NEXT = 1
    END = 2
    


class FfiConverterTypeUploadTaskAction(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.readI32()
        if variant == 1:
            return UploadTaskAction.NEXT
        if variant == 2:
            return UploadTaskAction.END
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value == UploadTaskAction.NEXT:
            buf.writeI32(1)
        if value == UploadTaskAction.END:
            buf.writeI32(2)



# CallbackError
# We want to define each variant as a nested class that's also a subclass,
# which is tricky in Python.  To accomplish this we're going to create each
# class separated, then manually add the child classes to the base class's
# __dict__.  All of this happens in dummy class to avoid polluting the module
# namespace.
class UniFFIExceptionTmpNamespace:
    class CallbackError(Exception):
        pass
    
    class UnexpectedError(CallbackError):
        def __str__(self):
            return "CallbackError.UnexpectedError({})".format(repr(super().__str__()))

    CallbackError.UnexpectedError = UnexpectedError
CallbackError = UniFFIExceptionTmpNamespace.CallbackError
del UniFFIExceptionTmpNamespace


class FfiConverterTypeCallbackError(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.readI32()
        if variant == 1:
            return CallbackError.UnexpectedError(
                FfiConverterString.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def write(value, buf):
        if isinstance(value, CallbackError.UnexpectedError):
            buf.writeI32(1)



import threading

class ConcurrentHandleMap:
    """
    A map where inserting, getting and removing data is synchronized with a lock.
    """

    def __init__(self):
        # type Handle = int
        self._left_map = {}  # type: Dict[Handle, Any]
        self._right_map = {}  # type: Dict[Any, Handle]

        self._lock = threading.Lock()
        self._current_handle = 0
        self._stride = 1


    def insert(self, obj):
        with self._lock:
            if obj in self._right_map:
                return self._right_map[obj]
            else:
                handle = self._current_handle
                self._current_handle += self._stride
                self._left_map[handle] = obj
                self._right_map[obj] = handle
                return handle

    def get(self, handle):
        with self._lock:
            return self._left_map.get(handle)

    def remove(self, handle):
        with self._lock:
            if handle in self._left_map:
                obj = self._left_map.pop(handle)
                del self._right_map[obj]
                return obj

# Magic number for the Rust proxy to call using the same mechanism as every other method,
# to free the callback once it's dropped by Rust.
IDX_CALLBACK_FREE = 0

class FfiConverterCallbackInterface:
    _handle_map = ConcurrentHandleMap()

    def __init__(self, cb):
        self._foreign_callback = cb

    def drop(self, handle):
        self.__class__._handle_map.remove(handle)

    @classmethod
    def lift(cls, handle):
        obj = cls._handle_map.get(handle)
        if not obj:
            raise InternalError("The object in the handle map has been dropped already")

        return obj

    @classmethod
    def read(cls, buf):
        handle = buf.readU64()
        cls.lift(handle)

    @classmethod
    def lower(cls, cb):
        handle = cls._handle_map.insert(cb)
        return handle

    @classmethod
    def write(cls, cb, buf):
        buf.writeU64(cls.lower(cb))

# Declaration and FfiConverters for OnGleanEvents Callback Interface

class OnGleanEvents:
    def initialize_finished():
        raise NotImplementedError

    def trigger_upload():
        raise NotImplementedError

    def start_metrics_ping_scheduler():
        raise NotImplementedError

    def cancel_uploads():
        raise NotImplementedError

    def shutdown():
        raise NotImplementedError

    

def py_foreignCallbackCallbackInterfaceOnGleanEvents(handle, method, args, buf_ptr):
    
    def invoke_initialize_finished(python_callback, args):
        rval = python_callback.initialize_finished()
        return RustBuffer.alloc(0)
        
    def invoke_trigger_upload(python_callback, args):
        rval = python_callback.trigger_upload()
        return RustBuffer.alloc(0)
        
    def invoke_start_metrics_ping_scheduler(python_callback, args):
        rval = python_callback.start_metrics_ping_scheduler()
        with RustBuffer.allocWithBuilder() as builder:
            FfiConverterBool.write(rval, builder)
            return builder.finalize()
    def invoke_cancel_uploads(python_callback, args):
        rval = python_callback.cancel_uploads()
        return RustBuffer.alloc(0)
        
    def invoke_shutdown(python_callback, args):
        rval = python_callback.shutdown()
        return RustBuffer.alloc(0)
        

    cb = FfiConverterCallbackInterfaceOnGleanEvents.lift(handle)
    if not cb:
        raise InternalError("No callback in handlemap; this is a Uniffi bug")

    if method == IDX_CALLBACK_FREE:
        FfiConverterCallbackInterfaceOnGleanEvents.drop(handle)
        # No return value.
        # See docs of ForeignCallback in `uniffi/src/ffi/foreigncallbacks.rs`
        return 0

    if method == 1:
        # Call the method and handle any errors
        # See docs of ForeignCallback in `uniffi/src/ffi/foreigncallbacks.rs` for details
        try:
            # Successful return
            buf_ptr[0] = invoke_initialize_finished(cb, args)
            return 1
        except BaseException as e:
            # Catch unexpected errors
            try:
                # Try to serialize the exception into a String
                buf_ptr[0] = FfiConverterString.lower(repr(e))
            except:
                # If that fails, just give up
                pass
            return -1
    if method == 2:
        # Call the method and handle any errors
        # See docs of ForeignCallback in `uniffi/src/ffi/foreigncallbacks.rs` for details
        try:
            try:
                # Successful return
                buf_ptr[0] = invoke_trigger_upload(cb, args)
                return 1
            except CallbackError as e:
                # Catch errors declared in the UDL file
                with RustBuffer.allocWithBuilder() as builder:
                    FfiConverterTypeCallbackError.write(e, builder)
                    buf_ptr[0] = builder.finalize()
                return -2
        except BaseException as e:
            # Catch unexpected errors
            try:
                # Try to serialize the exception into a String
                buf_ptr[0] = FfiConverterString.lower(repr(e))
            except:
                # If that fails, just give up
                pass
            return -1
    if method == 3:
        # Call the method and handle any errors
        # See docs of ForeignCallback in `uniffi/src/ffi/foreigncallbacks.rs` for details
        try:
            # Successful return
            buf_ptr[0] = invoke_start_metrics_ping_scheduler(cb, args)
            return 1
        except BaseException as e:
            # Catch unexpected errors
            try:
                # Try to serialize the exception into a String
                buf_ptr[0] = FfiConverterString.lower(repr(e))
            except:
                # If that fails, just give up
                pass
            return -1
    if method == 4:
        # Call the method and handle any errors
        # See docs of ForeignCallback in `uniffi/src/ffi/foreigncallbacks.rs` for details
        try:
            try:
                # Successful return
                buf_ptr[0] = invoke_cancel_uploads(cb, args)
                return 1
            except CallbackError as e:
                # Catch errors declared in the UDL file
                with RustBuffer.allocWithBuilder() as builder:
                    FfiConverterTypeCallbackError.write(e, builder)
                    buf_ptr[0] = builder.finalize()
                return -2
        except BaseException as e:
            # Catch unexpected errors
            try:
                # Try to serialize the exception into a String
                buf_ptr[0] = FfiConverterString.lower(repr(e))
            except:
                # If that fails, just give up
                pass
            return -1
    if method == 5:
        # Call the method and handle any errors
        # See docs of ForeignCallback in `uniffi/src/ffi/foreigncallbacks.rs` for details
        try:
            try:
                # Successful return
                buf_ptr[0] = invoke_shutdown(cb, args)
                return 1
            except CallbackError as e:
                # Catch errors declared in the UDL file
                with RustBuffer.allocWithBuilder() as builder:
                    FfiConverterTypeCallbackError.write(e, builder)
                    buf_ptr[0] = builder.finalize()
                return -2
        except BaseException as e:
            # Catch unexpected errors
            try:
                # Try to serialize the exception into a String
                buf_ptr[0] = FfiConverterString.lower(repr(e))
            except:
                # If that fails, just give up
                pass
            return -1
    

    # This should never happen, because an out of bounds method index won't
    # ever be used. Once we can catch errors, we should return an InternalException.
    # https://github.com/mozilla/uniffi-rs/issues/351

    # An unexpected error happened.
    # See docs of ForeignCallback in `uniffi/src/ffi/foreigncallbacks.rs`
    return -1

# We need to keep this function reference alive:
# if they get GC'd while in use then UniFFI internals could attempt to call a function
# that is in freed memory.
# That would be...uh...bad. Yeah, that's the word. Bad.
foreignCallbackCallbackInterfaceOnGleanEvents = FOREIGN_CALLBACK_T(py_foreignCallbackCallbackInterfaceOnGleanEvents)

# The FfiConverter which transforms the Callbacks in to Handles to pass to Rust.
rust_call(lambda err: _UniFFILib.ffi_glean_7e63_OnGleanEvents_init_callback(foreignCallbackCallbackInterfaceOnGleanEvents, err))
FfiConverterCallbackInterfaceOnGleanEvents = FfiConverterCallbackInterface(foreignCallbackCallbackInterfaceOnGleanEvents)



class FfiConverterOptionalUInt32(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.writeU8(0)
            return

        buf.writeU8(1)
        FfiConverterUInt32.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.readU8()
        if flag == 0:
            return None
        elif flag == 1:
            return FfiConverterUInt32.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class FfiConverterOptionalInt32(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.writeU8(0)
            return

        buf.writeU8(1)
        FfiConverterInt32.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.readU8()
        if flag == 0:
            return None
        elif flag == 1:
            return FfiConverterInt32.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class FfiConverterOptionalInt64(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.writeU8(0)
            return

        buf.writeU8(1)
        FfiConverterInt64.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.readU8()
        if flag == 0:
            return None
        elif flag == 1:
            return FfiConverterInt64.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class FfiConverterOptionalBool(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.writeU8(0)
            return

        buf.writeU8(1)
        FfiConverterBool.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.readU8()
        if flag == 0:
            return None
        elif flag == 1:
            return FfiConverterBool.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class FfiConverterOptionalString(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.writeU8(0)
            return

        buf.writeU8(1)
        FfiConverterString.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.readU8()
        if flag == 0:
            return None
        elif flag == 1:
            return FfiConverterString.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class FfiConverterOptionalTypeDatetime(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.writeU8(0)
            return

        buf.writeU8(1)
        FfiConverterTypeDatetime.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.readU8()
        if flag == 0:
            return None
        elif flag == 1:
            return FfiConverterTypeDatetime.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class FfiConverterOptionalTypeDistributionData(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.writeU8(0)
            return

        buf.writeU8(1)
        FfiConverterTypeDistributionData.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.readU8()
        if flag == 0:
            return None
        elif flag == 1:
            return FfiConverterTypeDistributionData.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class FfiConverterOptionalTypePingRateLimit(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.writeU8(0)
            return

        buf.writeU8(1)
        FfiConverterTypePingRateLimit.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.readU8()
        if flag == 0:
            return None
        elif flag == 1:
            return FfiConverterTypePingRateLimit.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class FfiConverterOptionalTypeRate(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.writeU8(0)
            return

        buf.writeU8(1)
        FfiConverterTypeRate.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.readU8()
        if flag == 0:
            return None
        elif flag == 1:
            return FfiConverterTypeRate.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class FfiConverterOptionalTypeRecordedExperiment(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.writeU8(0)
            return

        buf.writeU8(1)
        FfiConverterTypeRecordedExperiment.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.readU8()
        if flag == 0:
            return None
        elif flag == 1:
            return FfiConverterTypeRecordedExperiment.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class FfiConverterOptionalTypeLevelFilter(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.writeU8(0)
            return

        buf.writeU8(1)
        FfiConverterTypeLevelFilter.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.readU8()
        if flag == 0:
            return None
        elif flag == 1:
            return FfiConverterTypeLevelFilter.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class FfiConverterOptionalSequenceString(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.writeU8(0)
            return

        buf.writeU8(1)
        FfiConverterSequenceString.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.readU8()
        if flag == 0:
            return None
        elif flag == 1:
            return FfiConverterSequenceString.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class FfiConverterOptionalSequenceTypeRecordedEvent(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.writeU8(0)
            return

        buf.writeU8(1)
        FfiConverterSequenceTypeRecordedEvent.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.readU8()
        if flag == 0:
            return None
        elif flag == 1:
            return FfiConverterSequenceTypeRecordedEvent.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class FfiConverterOptionalSequenceTypeCowString(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.writeU8(0)
            return

        buf.writeU8(1)
        FfiConverterSequenceTypeCowString.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.readU8()
        if flag == 0:
            return None
        elif flag == 1:
            return FfiConverterSequenceTypeCowString.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class FfiConverterOptionalMapStringString(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.writeU8(0)
            return

        buf.writeU8(1)
        FfiConverterMapStringString.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.readU8()
        if flag == 0:
            return None
        elif flag == 1:
            return FfiConverterMapStringString.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class FfiConverterSequenceUInt8(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.writeI32(items)
        for item in value:
            FfiConverterUInt8.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.readI32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            FfiConverterUInt8.read(buf) for i in range(count)
        ]



class FfiConverterSequenceInt64(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.writeI32(items)
        for item in value:
            FfiConverterInt64.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.readI32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            FfiConverterInt64.read(buf) for i in range(count)
        ]



class FfiConverterSequenceString(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.writeI32(items)
        for item in value:
            FfiConverterString.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.readI32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            FfiConverterString.read(buf) for i in range(count)
        ]



class FfiConverterSequenceTypeCommonMetricData(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.writeI32(items)
        for item in value:
            FfiConverterTypeCommonMetricData.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.readI32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            FfiConverterTypeCommonMetricData.read(buf) for i in range(count)
        ]



class FfiConverterSequenceTypeRecordedEvent(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.writeI32(items)
        for item in value:
            FfiConverterTypeRecordedEvent.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.readI32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            FfiConverterTypeRecordedEvent.read(buf) for i in range(count)
        ]



class FfiConverterSequenceTypeCowString(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.writeI32(items)
        for item in value:
            FfiConverterTypeCowString.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.readI32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            FfiConverterTypeCowString.read(buf) for i in range(count)
        ]



class FfiConverterMapInt64Int64(FfiConverterRustBuffer):
    @classmethod
    def write(cls, items, buf):
        buf.writeI32(len(items))
        for (key, value) in items.items():
            FfiConverterInt64.write(key, buf)
            FfiConverterInt64.write(value, buf)

    @classmethod
    def read(cls, buf):
        count = buf.readI32()
        if count < 0:
            raise InternalError("Unexpected negative map size")

        # It would be nice to use a dict comprehension,
        # but in Python 3.7 and before the evaluation order is not according to spec,
        # so we we're reading the value before the key.
        # This loop makes the order explicit: first reading the key, then the value.
        d = {}
        for i in range(count):
            key = FfiConverterInt64.read(buf)
            val = FfiConverterInt64.read(buf)
            d[key] = val
        return d



class FfiConverterMapStringString(FfiConverterRustBuffer):
    @classmethod
    def write(cls, items, buf):
        buf.writeI32(len(items))
        for (key, value) in items.items():
            FfiConverterString.write(key, buf)
            FfiConverterString.write(value, buf)

    @classmethod
    def read(cls, buf):
        count = buf.readI32()
        if count < 0:
            raise InternalError("Unexpected negative map size")

        # It would be nice to use a dict comprehension,
        # but in Python 3.7 and before the evaluation order is not according to spec,
        # so we we're reading the value before the key.
        # This loop makes the order explicit: first reading the key, then the value.
        d = {}
        for i in range(count):
            key = FfiConverterString.read(buf)
            val = FfiConverterString.read(buf)
            d[key] = val
        return d


class FfiConverterTypeCowString:
    @staticmethod
    def write(value, buf):
        FfiConverterString.write(value, buf)

    @staticmethod
    def read(buf):
        return FfiConverterString.read(buf)

    @staticmethod
    def lift(value):
        return FfiConverterString.lift(value)

    @staticmethod
    def lower(value):
        return FfiConverterString.lower(value)

def glean_enable_logging():
    rust_call(_UniFFILib.glean_7e63_glean_enable_logging,)


def glean_enable_logging_to_fd(fd):
    fd = int(fd)
    
    rust_call(_UniFFILib.glean_7e63_glean_enable_logging_to_fd,
        FfiConverterUInt64.lower(fd))


def glean_initialize(cfg,client_info,callbacks):
    cfg = cfg
    
    client_info = client_info
    
    callbacks = callbacks
    
    rust_call(_UniFFILib.glean_7e63_glean_initialize,
        FfiConverterTypeInternalConfiguration.lower(cfg),
        FfiConverterTypeClientInfoMetrics.lower(client_info),
        FfiConverterCallbackInterfaceOnGleanEvents.lower(callbacks))


def glean_shutdown():
    rust_call(_UniFFILib.glean_7e63_glean_shutdown,)


def glean_initialize_for_subprocess(cfg):
    cfg = cfg
    
    return FfiConverterBool.lift(rust_call(_UniFFILib.glean_7e63_glean_initialize_for_subprocess,
        FfiConverterTypeInternalConfiguration.lower(cfg)))



def glean_set_upload_enabled(enabled):
    enabled = bool(enabled)
    
    rust_call(_UniFFILib.glean_7e63_glean_set_upload_enabled,
        FfiConverterBool.lower(enabled))


def glean_set_experiment_active(experiment_id,branch,extra):
    experiment_id = experiment_id
    
    branch = branch
    
    extra = dict((k, v) for (k, v) in extra.items())
    
    rust_call(_UniFFILib.glean_7e63_glean_set_experiment_active,
        FfiConverterString.lower(experiment_id),
        FfiConverterString.lower(branch),
        FfiConverterMapStringString.lower(extra))


def glean_set_experiment_inactive(experiment_id):
    experiment_id = experiment_id
    
    rust_call(_UniFFILib.glean_7e63_glean_set_experiment_inactive,
        FfiConverterString.lower(experiment_id))


def glean_test_get_experiment_data(experiment_id):
    experiment_id = experiment_id
    
    return FfiConverterOptionalTypeRecordedExperiment.lift(rust_call(_UniFFILib.glean_7e63_glean_test_get_experiment_data,
        FfiConverterString.lower(experiment_id)))



def glean_set_metrics_enabled_config(json):
    json = json
    
    rust_call(_UniFFILib.glean_7e63_glean_set_metrics_enabled_config,
        FfiConverterString.lower(json))


def glean_set_debug_view_tag(tag):
    tag = tag
    
    return FfiConverterBool.lift(rust_call(_UniFFILib.glean_7e63_glean_set_debug_view_tag,
        FfiConverterString.lower(tag)))



def glean_set_source_tags(tags):
    tags = list(x for x in tags)
    
    return FfiConverterBool.lift(rust_call(_UniFFILib.glean_7e63_glean_set_source_tags,
        FfiConverterSequenceString.lower(tags)))



def glean_set_log_pings(value):
    value = bool(value)
    
    rust_call(_UniFFILib.glean_7e63_glean_set_log_pings,
        FfiConverterBool.lower(value))


def glean_handle_client_active():
    rust_call(_UniFFILib.glean_7e63_glean_handle_client_active,)


def glean_handle_client_inactive():
    rust_call(_UniFFILib.glean_7e63_glean_handle_client_inactive,)


def glean_submit_ping_by_name(ping_name,reason = DEFAULT):
    ping_name = ping_name
    
    if reason is DEFAULT:
        reason = None
    else:
        reason = (None if reason is None else reason)
    
    rust_call(_UniFFILib.glean_7e63_glean_submit_ping_by_name,
        FfiConverterString.lower(ping_name),
        FfiConverterOptionalString.lower(reason))


def glean_submit_ping_by_name_sync(ping_name,reason = DEFAULT):
    ping_name = ping_name
    
    if reason is DEFAULT:
        reason = None
    else:
        reason = (None if reason is None else reason)
    
    return FfiConverterBool.lift(rust_call(_UniFFILib.glean_7e63_glean_submit_ping_by_name_sync,
        FfiConverterString.lower(ping_name),
        FfiConverterOptionalString.lower(reason)))



def glean_set_test_mode(enabled):
    enabled = bool(enabled)
    
    rust_call(_UniFFILib.glean_7e63_glean_set_test_mode,
        FfiConverterBool.lower(enabled))


def glean_test_destroy_glean(clear_stores,data_path = DEFAULT):
    clear_stores = bool(clear_stores)
    
    if data_path is DEFAULT:
        data_path = None
    else:
        data_path = (None if data_path is None else data_path)
    
    rust_call(_UniFFILib.glean_7e63_glean_test_destroy_glean,
        FfiConverterBool.lower(clear_stores),
        FfiConverterOptionalString.lower(data_path))


def glean_set_dirty_flag(flag):
    flag = bool(flag)
    
    rust_call(_UniFFILib.glean_7e63_glean_set_dirty_flag,
        FfiConverterBool.lower(flag))


def glean_get_upload_task():
    return FfiConverterTypePingUploadTask.lift(rust_call(_UniFFILib.glean_7e63_glean_get_upload_task,))



def glean_process_ping_upload_response(uuid,result):
    uuid = uuid
    
    result = result
    
    return FfiConverterTypeUploadTaskAction.lift(rust_call(_UniFFILib.glean_7e63_glean_process_ping_upload_response,
        FfiConverterString.lower(uuid),
        FfiConverterTypeUploadResult.lower(result)))



__all__ = [
    "InternalError",
    "ErrorType",
    "HistogramType",
    "LevelFilter",
    "Lifetime",
    "MemoryUnit",
    "PingUploadTask",
    "TimeUnit",
    "UploadResult",
    "UploadTaskAction",
    "ClientInfoMetrics",
    "CommonMetricData",
    "Datetime",
    "DistributionData",
    "InternalConfiguration",
    "PingRateLimit",
    "PingRequest",
    "Rate",
    "RecordedEvent",
    "RecordedExperiment",
    "TimerId",
    "glean_enable_logging",
    "glean_enable_logging_to_fd",
    "glean_initialize",
    "glean_shutdown",
    "glean_initialize_for_subprocess",
    "glean_set_upload_enabled",
    "glean_set_experiment_active",
    "glean_set_experiment_inactive",
    "glean_test_get_experiment_data",
    "glean_set_metrics_enabled_config",
    "glean_set_debug_view_tag",
    "glean_set_source_tags",
    "glean_set_log_pings",
    "glean_handle_client_active",
    "glean_handle_client_inactive",
    "glean_submit_ping_by_name",
    "glean_submit_ping_by_name_sync",
    "glean_set_test_mode",
    "glean_test_destroy_glean",
    "glean_set_dirty_flag",
    "glean_get_upload_task",
    "glean_process_ping_upload_response",
    "PingType",
    "CounterMetric",
    "TimespanMetric",
    "BooleanMetric",
    "StringMetric",
    "LabeledCounter",
    "LabeledBoolean",
    "LabeledString",
    "StringListMetric",
    "UrlMetric",
    "UuidMetric",
    "QuantityMetric",
    "TimingDistributionMetric",
    "MemoryDistributionMetric",
    "CustomDistributionMetric",
    "DatetimeMetric",
    "EventMetric",
    "RateMetric",
    "DenominatorMetric",
    "NumeratorMetric",
    "TextMetric",
    "CallbackError",
    "OnGleanEvents",
]

