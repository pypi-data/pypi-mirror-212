# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/01_parser.ipynb.

# %% auto 0
__all__ = ['regex', 'reg_email', 'db_name', 'parsePubmedData', 'parseArticle', 'parse_email', 'parseMayorKeys', 'parseMeshKeys',
           'parseKeys', 'parse_paperinfo', 'parse_author_xml']

# %% ../nbs/01_parser.ipynb 4
from datetime import datetime, timedelta, date
from collections import defaultdict, Counter
import re



# %% ../nbs/01_parser.ipynb 5
from fastcore.all import *
from .author import Autor



# %% ../nbs/01_parser.ipynb 6
regex = re.compile(("([a-z0-9!#$%&'*+\/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+\/=?^_`"
                    "{|}~-]+)*(@|\sat\s)(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?(\.|"
                    "\sdot\s))+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?)"))
reg_email = re.compile("[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\.[a-zA-Z0-9-.]+$")
db_name = ''

# %% ../nbs/01_parser.ipynb 7
def parsePubmedData(
                        pubmeddata:dict #Data retrieve from pubmedData
                   ) ->list :
    """
    Receive the xml section of PubmedData and return list of ids
    """
    ids = {x.attributes['IdType']: str(x) for x in pubmeddata['ArticleIdList']}
    return ids

# %% ../nbs/01_parser.ipynb 8
def parseArticle(article_info:dict #Dictionary containing information of the article ('Article' Key)
                )->dict: #Somethign
    """
    Function to extract information from an Article, including Title, Abstract, AutorList, journal and published Date
    :param article_info: dictionary from key Article of an Medline citation
    :return (dict): tuple of dictionary with information from paper and autors
    """
    # Extract information about paper content
    title = article_info['ArticleTitle']
    journal = article_info['Journal']['Title']
    published_date = article_info['Journal']['JournalIssue']['PubDate']
    if 'ArticleDate' in article_info.keys() and len(article_info['ArticleDate'])>0:
        date_dict = {k.lower():int(v) for k,v in article_info['ArticleDate'][0].items()}
        published = date(**date_dict)
    elif 'Year' in published_date:
        year = published_date['Year']
        published = date(int(year),1,1)
    elif 'MedlineDate' in published_date:
        try:
            published = date(re.findall(r'\d\d\d\d',published_date['MedlineDate'])[0],1,1)
        except:
            published = date(published_date['MedlineDate'][:4],1,1)
    try:
        abstract = '. '.join(article_info['Abstract']['AbstractText'])
    except:
        abstract = ''
    try:
        autorlist = article_info['AuthorList']
    except:
        print('no autors found, jumping next')
        autorlist = []
    return {'abstract': abstract, 'autorlist': autorlist, 'title': title, 'journal': journal,
            'published':published}

# %% ../nbs/01_parser.ipynb 9
def parse_email(affil_text:str #Affiliations information for each autor in the Article
               )->str:

    """
    Find email from the Affiliation text (Maybe use the reg_email regex and not the one in the function, TEST)
    """
    match = re.search(reg_email , affil_text) #r'[\w.-]+@[\w.-]+', affil_text)
    if match is not None:
        email = match.group()
        email = email.strip('.;,')
    else:
        email = ''
    return email

# %% ../nbs/01_parser.ipynb 11
def parseMayorKeys(citationInfo:dict #Dictionary from 'MedlineCitation' key containing keywords information
                  )->list:
    """
    Function to Parse the Mayor Keys from the Article.
    """
    keywordList = citationInfo['KeywordList']
    if len(keywordList) == 0:
        return []
    else:
        return [str(x) for x in keywordList[0] if x.attributes['MajorTopicYN'] == 'Y']

# %% ../nbs/01_parser.ipynb 12
def parseMeshKeys(citationInfo:dict #Dictionary from 'MedlineCitation' key containing keywords information
                 )->(list,list):
    """
    Function to Parse the Mayor and Minor MeSH Keys from the Article.
    """
    meshKeys = citationInfo['MeshHeadingList'] if 'MeshHeadingList' in citationInfo.keys() else []
    mayorkeys = [str(x['DescriptorName']) for x in meshKeys if x['DescriptorName'].attributes['MajorTopicYN']=='Y']
    minorKeys = [str(x['DescriptorName']) for x in meshKeys if x['DescriptorName'].attributes['MajorTopicYN']=='N']
    return mayorkeys, minorKeys

# %% ../nbs/01_parser.ipynb 13
def parseKeys(
    citationInfo:dict, #Dictionary from 'MedlineCitation' key containing keywords information
)->tuple[list]:
    """
    Function to retrieve the mayor keys as well as MEsh Keys
    """
    return parseMayorKeys(citationInfo), parseMeshKeys(citationInfo)

# %% ../nbs/01_parser.ipynb 14
def parse_paperinfo(
    paperinfo_xml:str #Xml data retreived from pubmed
    )->dict:
    """
    Function that parse the paper inforation and retrieve a dictionary 
    """
    PubmedData = parsePubmedData(paperinfo_xml['PubmedData'])
    article_xml = parseArticle(paperinfo_xml['MedlineCitation']['Article'])
    mayorKeys, (mayorMeshKeys, minorMeshKeys) = parseKeys(paperinfo_xml['MedlineCitation'])
    article_xml['mayorKeys'] = mayorKeys
    article_xml['mayorMesh'] = mayorMeshKeys
    article_xml['minorMesh'] = minorMeshKeys
    autorlist = []
    try:
        for author_xml in article_xml['autorlist']:
            if author_xml.attributes['ValidYN'] == 'N':
                continue
            autor_dict = parse_author_xml(author_xml)
            if autor_dict is None:
                continue
            autorlist.append(autor_dict)
    except:
        print('ERROR: parsing author {}'.format(author_xml))
    finally:
        article_xml['autorlist'] = autorlist
        PubmedData.update(article_xml)
    return PubmedData
    

# %% ../nbs/01_parser.ipynb 15
def parse_author_xml(
    autor_xml, #Xml data containing information for each author
    )->Autor:
    """
    Receive a dictionary from pubmed with the information of the Author. Retreive a Autor object with all the information parsed

    """
    # Return false if no author information found
    if 'CollectiveName' in autor_xml:
        return
    # try to parse information from XML
    try:
        #get Identifier (only orcid is used now so if they have identifier it should be the first value
        if len(autor_xml['Identifier']) > 0:
            autorID = str(autor_xml['Identifier'][0])
        else:
            autorID = ''
        #Get the affilaition details from that author, if he had
        if len(autor_xml['AffiliationInfo']) > 0:
            AFFs = ';'.join([affiliationinfo['Affiliation'] for affiliationinfo in autor_xml['AffiliationInfo']])
        else:
            AFFs = ''
        #Retrieving the name information, it is a must and should exist
        autorFN = autor_xml['ForeName']
        autorLN = autor_xml['LastName']
        autorIN = autor_xml['Initials']
        name = autorFN + ' ' + autorLN
        #Need to parse affiliation to get more details

        emails = parse_email(AFFs)
        data = {
            'Fname': autorFN,
            'Lname': autorLN,
            'emails': emails,
            'affiliations': AFFs, 
            'identifier': autorID,
            'name': name, 
            'initials': autorIN
               }  #
        # data.update(affilparsed)
        return Autor.parse_obj(data)

    except ValueError as e:
        print('not possible to get info value error')
        print(e)
        return
    except OSError as err:
        print("OS Error: {0}".format(err))
        return
    except:
        print('error en parsing')
        return
